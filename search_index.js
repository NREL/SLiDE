var documenterSearchIndex = {"docs":
[{"location":"man/build/eem/calibrate_regional.html","page":"Regional Calibration","title":"Regional Calibration","text":"SLiDE.calibrate_regional\nSLiDE._energy_calibration_input","category":"page"},{"location":"man/build/eem/calibrate_regional.html#SLiDE.calibrate_regional","page":"Regional Calibration","title":"SLiDE.calibrate_regional","text":"calibrate_regional(io::Dict, set::Dict, year::Integer)\n\nArguments\n\nd::Dict of DataFrames containing the model data.\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\nyear::Int: year for which to perform calibration\n\nReturns\n\nd::Dict of DataFrames containing the model data.\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/calibrate_regional.html#SLiDE._energy_calibration_input","page":"Regional Calibration","title":"SLiDE._energy_calibration_input","text":"_energy_calibration_input(d::Dict, set::Dict, year::Int)\n_energy_calibration_input(d::Dict, set::Dict)\n\nThis function prepares input for the EEM calibration routine. The indices of the output parameters will include yr only if year is included as an input parameter.\n\nDrop \"small\" values from input data.\nCalculate additional values for constraints:\nDefine va_yrrs = ld_yrrs + kd_yrrs\nAggregate regionally: tildeys_yrsg, tildex_yrg,   tildem_yrg, tildeva_yrs, tildeg_yrg,   tildei_yrg, tildecd_yrg.   For any parameter barz_yrrsg, tildez_yrsg = sum_r barz_yrrsg\nSeparate fvs_yrrs for labor (fvs_ld0) and capital (fvs_kd0).\nFilter netgen_yrr to include only values from SEDS input data.\nSet electricity imports/exports from/to the national market to/from Alaska and Hawaii to zero.\n(If T==Dict), fill zeros.\nSet lower bounds for all variables except for barld_yrrs, barkd_yrrs,  baryh_yrrg, and barcd_yrrg.\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_co2.html#CO2-Emissions","page":"Partition: CO2 Emissions","title":"CO2 Emissions","text":"","category":"section"},{"location":"man/build/eem/partition_co2.html","page":"Partition: CO2 Emissions","title":"Partition: CO2 Emissions","text":"SLiDE.partition_co2!","category":"page"},{"location":"man/build/eem/partition_co2.html#SLiDE.partition_co2!","page":"Partition: CO2 Emissions","title":"SLiDE.partition_co2!","text":"partition_co2!(dataset::Dataset, d::Dict, set::Dict, maps::Dict)\n\nThis function partitions and calculates CO2 emissions data.\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\nmaps::Dict of default mapping schematics and constants\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_co2.html","page":"Partition: CO2 Emissions","title":"Partition: CO2 Emissions","text":"SLiDE._partition_co2emiss!\nSLiDE._share_co2emiss!\nSLiDE._partition_secco2!\nSLiDE._partition_resco2!","category":"page"},{"location":"man/build/eem/partition_co2.html#SLiDE._partition_co2emiss!","page":"Partition: CO2 Emissions","title":"SLiDE._partition_co2emiss!","text":"barco_2_yrrsrcsec text million metric tons of CO2 = dfrac110^3\n    cdot tildeeq_yrrsrcneq ele sec text trillion btu\n    cdot f_src text kg CO2million btu\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_co2.html#SLiDE._share_co2emiss!","page":"Partition: CO2 Emissions","title":"SLiDE._share_co2emiss!","text":"Define:\n\nbeginaligned\ntildev_yrrg=es = left\n    tildeid_yrrgs vert g=e\nright\n\nmap_srightarrow sec = left\n    demand(ssrc) vert indcomtrnin sec\nright\nendaligned\n\nThen, use SLiDE.share_with to define delta^co2_yrrgsrightarrow sec:\n\ntildedelta^co2_yrrgsrightarrow sec = dfrac\n    v_yrrg=es circ map_srightarrow sec\n    sum_sec v_yrrg=es circ map_srightarrow sec\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_co2.html#SLiDE._partition_secco2!","page":"Partition: CO2 Emissions","title":"SLiDE._partition_secco2!","text":"For sec = (indcomtrn), use the sharing parameter delta^co2_yrrgsrightarrow sec calculated by SLiDE._share_co2emiss!.\n\ntildeco2_yrrgs = sum_sec left(\n    tildeco2_yrrsrcrightarrow g sec cdot\n    delta^co2_yrrgsrightarrow sec\nright)\n\nUse un-shared values for sec = (eleref) (which maps to s = (eleoil)):\n\ntildeco2_yrrgsneq res\n= tildeco2_yrrsrcrightarrow g sec circ map_secrightarrow s\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_co2.html#SLiDE._partition_resco2!","page":"Partition: CO2 Emissions","title":"SLiDE._partition_resco2!","text":"tildeco2_yrrg = left\n    co2_yrrsrcrightarrow gsec vert sec=res\nright\n\n\n\n\n\n","category":"function"},{"location":"api/model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api/model.html","page":"Model","title":"Model","text":"Describe model features","category":"page"},{"location":"man/build/io/calibrate_national.html","page":"National Calibration","title":"National Calibration","text":"SLiDE.calibrate_national\nSLiDE._national_calibration_input","category":"page"},{"location":"man/build/io/calibrate_national.html#SLiDE.calibrate_national","page":"National Calibration","title":"SLiDE.calibrate_national","text":"calibrate_national(dataset::Dataset, io::Dict, set::Dict)\ncalibrate_national(io::Dict, set::Dict, year::Integer)\n\nArguments\n\nd::Dict of DataFrames containing the model data.\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\nyear::Int: year for which to perform calibration\n\nReturns\n\nd::Dict of DataFrames containing the model data\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/calibrate_national.html#SLiDE._national_calibration_input","page":"National Calibration","title":"SLiDE._national_calibration_input","text":"_national_calibration_input(d::Dict, set::Dict, year::Int)\n_national_calibration_input(d::Dict, set::Dict)\n\nThis function prepares the input for the calibration routine:\n\nSelect parameters relevant to the calibration routine.\nFor all parameters except taxes (ta0, tm0), set negative values to zero:  x = maxleft0 xright\nIn the case of final demand, only set negative values to zero for fd = pce:  fd_gfd = max0 fd_gfd\nFill all \"missing\" values with zeros to generate a complete dataset. This is relevant  to how the penalty for missing keys is applied in the objective function.\n\nArguments\n\nd::Dict{Symbol,DataFrame}: all input parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\nyear::Int overwhich to calibrate\n\nReturns\n\nd::Dict{Symbol, Dict}: input variables\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.),   updated to include necessary set permutations.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/calibrate.html#Calibrate","page":"Calibrate","title":"Calibrate","text":"","category":"section"},{"location":"api/internals/calibrate.html","page":"Calibrate","title":"Calibrate","text":"Modules = [SLiDE]\nPages = [\"build/calibrate/calibrate_io.jl\"]\nPublic = false","category":"page"},{"location":"api/internals/calibrate.html#SLiDE._calibration_input-Union{Tuple{T}, Tuple{Function,Any,Any,Type{T}}} where T<:Union{DataFrames.DataFrame, Dict}","page":"Calibrate","title":"SLiDE._calibration_input","text":"\n\n\n\n","category":"method"},{"location":"api/internals/calibrate.html#SLiDE._calibration_output-Tuple{JuMP.Model,Dict,Integer}","page":"Calibrate","title":"SLiDE._calibration_output","text":"\n\n\n\n","category":"method"},{"location":"api/internals/calibrate.html#SLiDE._calibration_set!-Tuple{Any}","page":"Calibrate","title":"SLiDE._calibration_set!","text":"\n\n\n\n","category":"method"},{"location":"api/types/scale.html#Scale","page":"Scale","title":"Scale","text":"","category":"section"},{"location":"api/types/scale.html","page":"Scale","title":"Scale","text":"Modules = [SLiDE]\nPrivate = false\nFilter = t -> t <: SLiDE.Scale\nOrder = [:type]","category":"page"},{"location":"api/types/scale.html#SLiDE.Mapping","page":"Scale","title":"SLiDE.Mapping","text":"mutable struct Mapping <: Scale\n    data::DataFrame\n    from::Union{Symbol,Array{Symbol,1}}\n    to::Union{Symbol,Array{Symbol,1}}\n    on::Union{Symbol,Array{Symbol,1}}\n    direction::Symbol\nend\n\nStore mapping information for scaling. This should NOT include any multiplication factors.\n\nArguments\n\ndata::DataFrame: input file name\nfrom::Union{Symbol,Array{Symbol,1}}: data columns that overlap with on\nto::Union{Symbol,Array{Symbol,1}}: data columns that DO NOT overlap with on\non::Union{Symbol,Array{Symbol,1}}: columns that can be mapped with data\ndirection::Symbol: indicator describing whether to aggregate/disaggregate\n\n\n\n\n\n","category":"type"},{"location":"api/types/scale.html#SLiDE.Mapping-Tuple{DataFrames.DataFrame}","page":"Scale","title":"SLiDE.Mapping","text":"\n\n\n\n","category":"method"},{"location":"api/types/scale.html#SLiDE.Weighting","page":"Scale","title":"SLiDE.Weighting","text":"mutable struct Weighting <: Scale\n    data::DataFrame\n    constant::Array{Symbol,1}\n    from::Union{Symbol,Array{Symbol,1}}\n    to::Union{Symbol,Array{Symbol,1}}\n    on::Union{Symbol,Array{Symbol,1}}\n    direction::Symbol\nend\n\nStore mapping AND weighting information for scaling. math 1+1\n\nArguments\n\ndata::DataFrame: input file name\nconstant::Array{Symbol,1}: data columns that are included in but not changed by the mapping process\nfrom::Union{Symbol,Array{Symbol,1}}: data columns that overlap with on\nto::Union{Symbol,Array{Symbol,1}}: data columns that DO NOT overlap with on\non::Union{Symbol,Array{Symbol,1}}: columns that can be mapped with data\ndirection::Symbol: indicator describing whether to aggregate/disaggregate\n\n\n\n\n\n","category":"type"},{"location":"api/types/scale.html#SLiDE.Weighting-Tuple{DataFrames.DataFrame}","page":"Scale","title":"SLiDE.Weighting","text":"\n\n\n\n","category":"method"},{"location":"api/functions/parse.html#Parse","page":"Parse","title":"Parse","text":"","category":"section"},{"location":"api/functions/parse.html#Load","page":"Parse","title":"Load","text":"","category":"section"},{"location":"api/functions/parse.html","page":"Parse","title":"Parse","text":"Modules = [SLiDE]\nPages = [\"parse/load_data.jl\"]\nPrivate = false","category":"page"},{"location":"api/functions/parse.html#Verify","page":"Parse","title":"Verify","text":"","category":"section"},{"location":"api/functions/parse.html","page":"Parse","title":"Parse","text":"Modules = [SLiDE]\nPages = [\"parse/check_data.jl\"]\nPrivate = false","category":"page"},{"location":"api/functions/parse.html#SLiDE.benchmark_against-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}","page":"Parse","title":"SLiDE.benchmark_against","text":"benchmark_against(df_calc, df_bench; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"api/functions/parse.html#SLiDE.compare_keys-Tuple{Array{DataFrames.DataFrame,1},Array{Symbol,1}}","page":"Parse","title":"SLiDE.compare_keys","text":"compare_keys(df_lst::Array{DataFrame,1}, inds::Array{Symbol,1})\n\nArguments\n\ndf_lst::Array{DataFrame,1}: List of DataFrames to compare.   These must all share the same column names.\ninds::Array{Symbol,1}: List of IDs that describe each DataFrame and track which   values/keys are present in each DataFrame. There must be an equal number of input   DataFrames and IDs.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/parse.html#SLiDE.compare_summary-Tuple{Array{DataFrames.DataFrame,1},Array{Symbol,1}}","page":"Parse","title":"SLiDE.compare_summary","text":"compare_summary(df_lst::Array{DataFrame,1}, inds::Array{Symbol,1}; kwargs...)\n\nArguments\n\ndf::Array{DataFrame,1}: List of DataFrames to compare.   These must all share the same column names.\nd::Array{Dict,1}: Array of dictonaries of DataFrames to compare.\nid::Array{Symbol,1}: List of IDs that describe each DataFrame and track which   values/keys are present in each DataFrame. There must be an equal number of input   DataFrames and IDs.\n\nKeywords\n\ntol::Float64 = 1E-6: Tolerance used when determining whether values are equal.   Default values is 1E-6.\ncomplete_summary::Bool = false: Should we include the full summary DataFrame or only the   problematic rows (i.e., ones where either equal_keys = false or equal_values = false)?\n\nReturns\n\ndf::DataFrame: Summary DataFrame including the index columns and values from the original   df, marked to indicate which input DataFrame they came from, the reldiff between   the values, and booleans equal_key (are values for the index present in both DataFrames?)   and equal_value (are the values the same within the given tol?)\nd::Dict: Dictionary of summary DataFrames\n\n\n\n\n\n","category":"method"},{"location":"api/functions/parse.html#SLiDE.compare_values-Tuple{Array{DataFrames.DataFrame,1},Array{Symbol,1}}","page":"Parse","title":"SLiDE.compare_values","text":"compare_values(df_lst::Array{DataFrame,1}, inds::Array{Symbol,1})\n\nArguments\n\ndf_lst::Array{DataFrame,1}: List of DataFrames to compare.   These must all share the same column names.\ninds::Array{Symbol,1}: List of IDs that describe each DataFrame and track which   values/keys are present in each DataFrame. There must be an equal number of input   DataFrames and IDs.\n\nKeyword Argument\n\ntol::Float64 = 1E-6: Tolerance used when determining whether values are equal.   Default values is 1E-6.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/parse.html#SLiDE.verify_over-Tuple{DataFrames.DataFrame,Any}","page":"Parse","title":"SLiDE.verify_over","text":"verify_over(df::DataFrame, col::Any; tol = 1E-6)\n\n\n\n\n\n","category":"method"},{"location":"man/build/eem/partition_seds.html#Energy-Parameters","page":"Partition: Energy and Electricity","title":"Energy Parameters","text":"","category":"section"},{"location":"man/build/eem/partition_seds.html","page":"Partition: Energy and Electricity","title":"Partition: Energy and Electricity","text":"SLiDE.partition_seds","category":"page"},{"location":"man/build/eem/partition_seds.html#SLiDE.partition_seds","page":"Partition: Energy and Electricity","title":"SLiDE.partition_seds","text":"partition_seds(dataset::Dataset, d::Dict, set::Dict)\n\nThis function prepares SEDS energy and electricity data for the Energy-Environment Module\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\nReturns\n\nd::Dict of SEDS energy and electricity data\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\nmaps::Dict of default mapping schematics and constants\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html","page":"Partition: Energy and Electricity","title":"Partition: Energy and Electricity","text":"SLiDE.partition_elegen!","category":"page"},{"location":"man/build/eem/partition_seds.html#SLiDE.partition_elegen!","page":"Partition: Energy and Electricity","title":"SLiDE.partition_elegen!","text":"Electricity generation by source.\n\nbarele_yrrsrcsec = leftsedsleft( yrrsrcsec right)\nvert yr  r  (ffre) in src  sec = ele right\n\nFor fossil fuels, use heatrate to convert as follows:\n\nbarele_yrrffin srcsec text billion kWh\n= 10^3 cdot\ndfracbarele_yrrffin srcsec text trillion btu\n      barheatrate_yrsrc text btukWh\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html","page":"Partition: Energy and Electricity","title":"Partition: Energy and Electricity","text":"SLiDE.partition_energy!\nSLiDE._partition_energy_supply\nSLiDE._partition_energy_ref\nSLiDE._partition_energy_ind\nSLiDE._partition_energy_price","category":"page"},{"location":"man/build/eem/partition_seds.html#SLiDE.partition_energy!","page":"Partition: Energy and Electricity","title":"SLiDE.partition_energy!","text":"barenergy_yrrsrcsec = leftsedsleft( yrrsrcsec right)\nvert yr  r  e in src  ed in sec right\n\nSLiDE._partition_energy_supply adds supply information from the electricity generation dataset output by SLiDE.partition_elegen!. The following functions are used to calculate values or make adjustments to values in the energy dataset. These operations must occur in the following order:\n\nSLiDE._partition_energy_ref\nSLiDE._partition_energy_ind\nSLiDE._partition_energy_price\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_energy_supply","page":"Partition: Energy and Electricity","title":"SLiDE._partition_energy_supply","text":"barsupply_yrrsrc=ele = sum_src barele_yrrsrc\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_energy_ref","page":"Partition: Energy and Electricity","title":"SLiDE._partition_energy_ref","text":"barref_yrrsrc=ele text billion kWh\n=\nbarref_yrrsrc=ele text trillion btu\ncdot\ndfracbarind_yrrsrc=ele text billion kWh\n      barind_yrrsrc=ele text trillion btu\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_energy_ind","page":"Partition: Energy and Electricity","title":"SLiDE._partition_energy_ind","text":"barind_yrrsrc=(ffele)\n= barind_yrrsrc=(ffele)\n- barref_yrrsrc=(ffele)\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_energy_price","page":"Partition: Energy and Electricity","title":"SLiDE._partition_energy_price","text":"beginaligned\nbarff_yrrsec=ele text USDmillion btu\n= 10^3 cdot\ndfracbarff_yrrsec=ele text billion USD\n      barff_yrrsec=ele text trillion btu\n\nbarele_yrrsec text USDthousand kWh\n= 10^3 cdot\ndfracbarele_yrrsec text billion USD\n      barele_yrrsec text billion kWh\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html","page":"Partition: Energy and Electricity","title":"Partition: Energy and Electricity","text":"SLiDE._partition_cprice!\nSLiDE._partition_pedef!\nSLiDE._partition_pe0!","category":"page"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_cprice!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_cprice!","text":"cprice(yr,r) [USD per million btu], crude oil price\n\nbeginaligned\ntildek_yrrsrc text million btubarrel = left\n    seds left( yr r src sec right) vert yr r src=cru sec=supply\nright\n\ntildep_yrrsrcsec text USDmillion btu = dfrac\n    barcrude oil_yr text USDbarrel\n    tildek_yrrsrc text million btubarrel\ncirc vec1_demsecin sec\nendaligned\n\nFill zero (yr,r,src=cru,sec) values using barp_yrsrc=crusec as computed by  SLiDE.impute_mean, under the condition that crude oil quantity is defined:\n\ntildeq^star_yrrsrc=crusec text trillion btu = left\n    seds left( yr r src sec right) vert yr r src=cru demsecin sec\nright\n\ntildep_yrrsrcsec text USDmillion btu =\nbegincases\ntildep_yrrsrc=crusec  tildep_yrrsrcsec\n\nbarp_yrsrc=crusec circ vec1_r  tildep_yrrsrcsec tildeq^star_yrrsrc=crusec  0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_pedef!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_pedef!","text":"pedef(yr,r,src), average energy demand price. This parameter can be calculated from prices tildep_yrrsrcsec and quantities  tildeq_yrrsrcsec for the following (src,sec).\n\nleft(tildep tildeqright)_yrrsrcsec\n= left\n    seds left( yr r src sec right) vert yr r (ffele)in src demsecin sec\nright\n\nAverage energy demand price hatp_yrrsrc is calculated as its tildeq_yrrsrcsec-weighted sectoral aggregate:\n\nhatp_yrrsrc = dfrac\n    sum_sec left( tildep_yrrsrcsec cdot tildeq_yrrsrcsec right)\n    sum_sec tildeq_yrrsrcsec\n\nFill missing (yr,r,src) values using barp_yrsrc, as computed by SLiDE.impute_mean, weighted by sum_sec q_yrrsrcsec.\n\ntildepedef_yrrsrc =\nbegincases\ntildepedef_yrrsrc  sum_sec q_yrrsrcsec neq 0\n\nbarpedef_yrsrc  sum_sec q_yrrsrcsec = 0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_pe0!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_pe0!","text":"pe0(yr,r,src,sec), energy demand prices\n\nbeginaligned\ntildep_yrrsrcneq crusec = left\n    energy left( yr r src sec right) vert yr r src demsecin sec\nright\n\ntildep_yrrsrcsec = \nbegincases\ntildep_yrrsrcneq crusec  srcneq cru tildep_yrrsrcneq crusecneq 0\n\nhatp_yrrsrcneq cru circ vec1_sec  srcneq cru tildep_yrrsrcneq cru = 0\n\ntildep_yrrsrc=crusec  src=cru\nendcases\nendaligned\n\nwith tildep_yrrsrc=crusec calculated by SLiDE._partition_cprice! and hatp_yrrsrc=cru calculated by SLiDE._partition_pedef!\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html","page":"Partition: Energy and Electricity","title":"Partition: Energy and Electricity","text":"SLiDE._partition_ps0!\nSLiDE._partition_prodval!\nSLiDE._partition_shrgas!","category":"page"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_ps0!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_ps0!","text":"ps0(yr,src), crude oil and natural gas supply prices\n\nbeginaligned\nbarps_yrsrc = min_rsec tildep_yrrsrcsec\n\nbarps_rsrc=cru = frac12barps_rsrc=oil\nendaligned\n\nwith tildepe_yrrsrcsec calculated by SLiDE._partition_pe0!.\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_prodval!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_prodval!","text":"prodval(yr,r,src), production value (using supply prices)\n\nbeginaligned\np_yrsrc text USDmillion btu = left\n    barps_yrsrc vert crugas in src\nright\n\ntildeq_yrrsrc text trillion btu = left\n    seds left( yr r src sec right) vert yr r crugasin src sec=supply\nright\n\nprodval_yrrsrc text billion USD = frac110^3\n    cdot p_yrsrc text USDmillion btu\n    cdot prodbtu_yrrsrc text trillion btu\nendaligned\n\nwith barps_yrsrc calculated by SLiDE._partition_ps0!.\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_shrgas!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_shrgas!","text":"shrgas(yr,r,src), regional share of production for gas extraction\n\ndelta_yrrsrc = dfracprodval_yrrsrcsum_src prodval_yrrsrc\n\nFill missing (yr,src) values using bardelta_yrsrc as computed by SLiDE.impute_mean, under the condition that there is some non-zero supply of goods from the cng sector:\n\nys0^star_yrrsrc = \n    sum_g ys_yrrs=cngg circ vec1_demsec in sec  0\n\ndelta_yrrsrc = \nbegincases\ndelta_yrrsrc  sum_srcprodval_yrrsrc neq 0\n\nbardelta_yrrsrc  sum_srcprodval_yrrsrc=0 ys0^star_yrrsrc  0\nendcases\n\nEnsure all sectoral shares sum to 1.\n\ndelta_yrrsrc = dfracdelta_yrrsrcsum_srcdelta_yrrsrc\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html","page":"Partition: Energy and Electricity","title":"Partition: Energy and Electricity","text":"SLiDE._partition_netgen!\nSLiDE._partition_trdele!\nSLiDE._partition_pctgen!\nSLiDE._partition_eq0!\nSLiDE._partition_ed0!\nSLiDE._partition_emarg0!\nSLiDE._partition_ned0!","category":"page"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_netgen!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_netgen!","text":"netgen(yr,r), net interstate electricity flow This can be computed using both SEDS data and regional parameters. Using SEDS data:\n\nbeginaligned\np text USDthousand kWh = left\n    barps_yrsrc vert src=ele\nright\n\nq text billion kWh = left\n    seds(yrrsrcsec) vert src=ele sec=netgen\nright\nendaligned\n\nwith barps_yrsrc calculated by SLiDE._partition_ps0!.\n\nv_yrr text billion USD = dfrac110^3 cdot dfrac\n    p text USDthousand kWh\n    q text billion kWh\n\nUsing regional parameters:\n\nv_yrr = nd_yrrg=ele - xn_yrrg=ele\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_trdele!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_trdele!","text":"trdele(yr,r,g=ele,t), electricity imports-exports to/from U.S.\n\ntildetrdele_yrrt text billion usd = left\n    seds left( yr r src sec right) vert yr r src=ele importsexportsin sec\nright\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_pctgen!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_pctgen!","text":"pctgen(yr,r,src,sec), percent of electricity generation\n\npctgen_yrrsrc = left\n    dfracelegen_yrrsrcsum_src elegen_yrrsrc vert ff in src\nright circ vec1_sec=ele\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_eq0!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_eq0!","text":"eq0(yr,r,src,sec), energy demand\n\ntildeeq_yrrsrcsec = left\n    energy left( yr r src sec right) vert yr r ein src demsecin sec\nright\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_ed0!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_ed0!","text":"ed0(yr,r,src,sec), energy demand\n\ntildeed_yrrsrcsec = dfrac\n    tildepe_yrrsrcsec\n    tildeeq_yrrsrcsec\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_emarg0!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_emarg0!","text":"emarg0(yr,r,src,sec), margin demand for energy markups\n\ntildeemarg_yrrsrcsec = dfrac\n    tildepe_yrrsrcsec - tildeps_yrsrc\n    tildeeq_yrrsrcsec\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/partition_seds.html#SLiDE._partition_ned0!","page":"Partition: Energy and Electricity","title":"SLiDE._partition_ned0!","text":"ned0(yr,r,src,sec), net energy demand\n\ntildened_yrrsrcsec = tildeed_yrrsrcsec - tildeemarg_yrrsrcsec\n\n\n\n\n\n","category":"function"},{"location":"man/scale/overview.html#Scaling","page":"Scale","title":"Scaling","text":"","category":"section"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"The build stream produces state-level (regionally) model parameters at the summary-level (sectorally).","category":"page"},{"location":"man/scale/overview.html#Regional-Scaling","page":"Scale","title":"Regional Scaling","text":"","category":"section"},{"location":"man/scale/overview.html#Aggregation","page":"Scale","title":"Aggregation","text":"","category":"section"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"By default, the SLiDE build stream produces regional data at the state level.","category":"page"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"BEA and Census Bureau used to produce shares via SLiDE.share_region and applied via SLiDE.disaggregate_region is aggregated to the desired level immediately upon being read into the build stream.","category":"page"},{"location":"man/scale/overview.html#Disaggregation","page":"Scale","title":"Disaggregation","text":"","category":"section"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"Regional disaggregation will be tackeled during future development phases Source data is regional-specific and available for a variety of regional divisions: state, CBSA, CSA.","category":"page"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"Source Data Region State County CSA CBSA\nBEA Supply/Use N/A N/A N/A N/A N/A\n GSP ✅ ✅ ✅ ❌ ✅\n PCE ✅ ✅ ❌ ❌ ❌\nCensus CFS ❌ ✅ ❌ ✅ ✅\n SGF     \n UTD     \n NASS ❌ ✅ ❌ ❌ ❌\n      \n      ","category":"page"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"The regional level identifiers used are consistent with those from the 2010 Census Summary File 1. Codes listed in the Census Delineation Files are used to identify regions.","category":"page"},{"location":"man/scale/overview.html#Sectoral-Scaling","page":"Scale","title":"Sectoral Scaling","text":"","category":"section"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"By default, there are 73 summary-level goods/sectors. These can be disaggregated into 409 detail-level goods/sectors using the blueNOTE sectoral scaling map.","category":"page"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"Scaling features enable the following options:","category":"page"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"Select a subset of summary-level or detail-level goods/sectors to examine.\nSelect a combination of summary- and detail-level goods/sectors.\nAggregate summary- and/or detail-level goods/sectors into those specified in a user-defined map.","category":"page"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"SLiDE.scale_sector\nSLiDE.scale_sector!","category":"page"},{"location":"man/scale/overview.html#SLiDE.scale_sector","page":"Scale","title":"SLiDE.scale_sector","text":"scale_sector(dataset::Dataset, d::Dict, set::Dict; kwargs...)\n\nThis function scales model parameters defined over 73 summary-level sectors to a user-defined scheme.\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/scale/overview.html#Aggregation-2","page":"Scale","title":"Aggregation","text":"","category":"section"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"SLiDE.aggregate_sector!\nSLiDE.aggregate_tax_with!","category":"page"},{"location":"man/scale/overview.html#SLiDE.aggregate_sector!","page":"Scale","title":"SLiDE.aggregate_sector!","text":"aggregate_sector!(d::Dict, set::Dict, mapping::Mapping; kwargs...)\n\nThis function performs the sectoral aggregation for all model parameters.\n\nTaxes (ta, tm, ty) are aggregated using SLiDE.aggregate_tax_with!.\nAll other parameters are disaggregated using SLiDE.scale_with.\n\n\n\n\n\n","category":"function"},{"location":"man/scale/overview.html#SLiDE.aggregate_tax_with!","page":"Scale","title":"SLiDE.aggregate_tax_with!","text":"aggregate_tax_with!(d::Dict, set::Dict, mapping::Mapping, tax::Symbol, key::Symbol)\n\nThis function is applied to the following tax rates, which are scaled by a the corresponding parameters. It returns the aggregated tax rate as well as the aggregated scaling parameter.\n\nta(yr,r,g), absorption taxes, scaled by domestic absorption, a(yr,r,g):   ```math   \\begin{aligned}   \\bar{a}{yr,r,g} &= \\bar{a}{yr,r,gg} \\circ map{gg\\rightarrow g}   \\\n  \\bar{ta}{yr,r,g} &= \\dfrac       {\\left(\\bar{ta}{yr,r,gg} \\cdot \\bar{a}{yr,r,gg} \\right) \\circ map{gg\\rightarrow g}}       {                                  \\bar{a}{yr,r,g}}   \\end{aligned}   ```\ntm(yr,r,g), import taxes, scaled by foreign imports, m(yr,r,g):   ```math   \\begin{aligned}   \\bar{m}{yr,r,g} &= \\bar{m}{yr,r,gg} \\circ map{gg\\rightarrow g}   \\\n  \\bar{tm}{yr,r,g} &= \\dfrac       {\\left(\\bar{tm}{yr,r,gg} \\cdot \\bar{m}{yr,r,gg} \\right) \\circ map{gg\\rightarrow g}}       {                                  \\bar{m}{yr,r,g}}   \\end{aligned}   ```\nty(yr,r,s), production taxes, scaled by total regional sectoral output, ys(yr,r,s,g):   ```math   \\begin{aligned}   \\bar{ys}{yr,r,s,g} &= \\bar{ys}{yr,r,ss,gg} \\circ map{ss\\rightarrow s, gg\\rightarrow g}   \\\n  \\bar{ty}{yr,r,s} &= \\dfrac       {\\left(\\bar{ty}{yr,r,ss} \\cdot \\sum{gg} \\bar{ys}{yr,r,ss,gg} \\right) \\circ map{ss\\rightarrow s}}       {                                  \\sum{g}  \\bar{ys}{yr,r,s ,g}}   \\end{aligned}   ```\n\nwhere gg, ss represent disaggregate-level goods and sectors and g, s represent aggregate-level goods and sectors.\n\nArguments\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\nmapping::Mapping defining map_ggrightarrow g\ntax::Symbol: tax parameter key\nkey::Symbol: scaling parameter key\n\nReturns\n\nd[tax]::DataFrame: mapped tax parameter\nd[key]::DataFrame: mapped scaling parameter\n\n\n\n\n\n","category":"function"},{"location":"man/scale/overview.html#Disaggregation-2","page":"Scale","title":"Disaggregation","text":"","category":"section"},{"location":"man/scale/overview.html","page":"Scale","title":"Scale","text":"SLiDE.disaggregate_sector!","category":"page"},{"location":"man/scale/overview.html#SLiDE.disaggregate_sector!","page":"Scale","title":"SLiDE.disaggregate_sector!","text":"disaggregate_sector!(d::Dict, set::Dict; kwargs...)\ndisaggregate_sector!(d::Dict, set::Dict, weighting::Weighting; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"man/data/overview.html#Data","page":"Overview","title":"Data","text":"","category":"section"},{"location":"man/data/overview.html#blueNOTE-Data-Set","page":"Overview","title":"blueNOTE Data Set","text":"","category":"section"},{"location":"man/data/overview.html","page":"Overview","title":"Overview","text":"This is the SLiDE version of the blueNOTE dataset developed by the Wisconsin National Data Consortium (WiNDC). The SLiDE datastream is built on the groundwork laid by Thomas F. Rutherford, Andrew Schreiber, Gökçe Akin-Olçum, and Christoph Böhringer.","category":"page"},{"location":"man/data/overview.html","page":"Overview","title":"Overview","text":"The data necessary to execute the SLiDE buildstream is stored in the following structure:","category":"page"},{"location":"man/data/overview.html","page":"Overview","title":"Overview","text":"data/\n├── coremaps/\n└── coremaps/\n└── input/","category":"page"},{"location":"man/data/overview.html#Data-Sources","page":"Overview","title":"Data Sources","text":"","category":"section"},{"location":"man/data/overview.html","page":"Overview","title":"Overview","text":"The blueNOTE dataset is compiled of the following data:","category":"page"},{"location":"man/data/overview.html","page":"Overview","title":"Overview","text":"Bureau of Economic Analysis\nSupply and Use Tables (BEA)\nGross State Product (GSP)\nPersonal Consumer Expenditures (PCE)\nCensus Bureau\nCommodity Flow Survey (CFS)\nState Government Finance (SGF)\nState Exports/Imports (UTD)\nEnergy Information Administration\nState Energy Data System (SEDS)","category":"page"},{"location":"man/scale/sector.html#Sectoral-Scaling","page":"Sectoral Scaling","title":"Sectoral Scaling","text":"","category":"section"},{"location":"man/scale/sector.html","page":"Sectoral Scaling","title":"Sectoral Scaling","text":"The build stream produces state-level (regionally) model parameters at the summary-level (sectorally). By default, there are 73 summary-level goods/sectors. These can be disaggregated into 409 detail-level goods/sectors using the blueNOTE sectoral scaling map.","category":"page"},{"location":"man/scale/sector.html","page":"Sectoral Scaling","title":"Sectoral Scaling","text":"Scaling features enable the following options:","category":"page"},{"location":"man/scale/sector.html","page":"Sectoral Scaling","title":"Sectoral Scaling","text":"Select a subset of summary-level or detail-level goods/sectors to examine.\nSelect a combination of summary- and detail-level goods/sectors.\nAggregate summary- and/or detail-level goods/sectors into those specified in a user-defined map.","category":"page"},{"location":"man/scale/sector.html","page":"Sectoral Scaling","title":"Sectoral Scaling","text":"SLiDE.scale_with\nSLiDE.compound_for!\nSLiDE.filter_for!","category":"page"},{"location":"man/scale/sector.html","page":"Sectoral Scaling","title":"Sectoral Scaling","text":"SLiDE.disaggregate_sector!\nSLiDE.aggregate_sector!\nSLiDE.aggregate_tax_with!","category":"page"},{"location":"lib/buildstream.html#Build-Stream","page":"Build Stream","title":"Build Stream","text":"","category":"section"},{"location":"lib/buildstream.html","page":"Build Stream","title":"Build Stream","text":"Overview of how BuildStream works to build the national model. There are four steps required to build the cleaned input data for use in the model.","category":"page"},{"location":"lib/buildstream.html","page":"Build Stream","title":"Build Stream","text":"Partition. Divide BEA supply/use data into parameters.\nCalibrate.\nShare. Divide data into regional component. This will guide how to break the national data into regional components by state or county.\nDisaggregate.","category":"page"},{"location":"api/functions/scale.html#Scale","page":"Scale","title":"Scale","text":"","category":"section"},{"location":"api/functions/scale.html","page":"Scale","title":"Scale","text":"SLiDE.scale_with\nSLiDE.compound_for!\nSLiDE.filter_for!","category":"page"},{"location":"api/functions/scale.html#SLiDE.scale_with","page":"Scale","title":"SLiDE.scale_with","text":"scale_with(df::DataFrame, x::Weighting)\n\nThis function maps df: x.from -> x.to, multiplying by any associated share specified in x.data. For a parameter barz,\n\nbeginaligned\nbarz_ca = sum_aa left( barz_caa cdot tildedelta_caa rightarrow a right)\nendaligned\n\nwhere c (x.constant) represents the index/ices included in, but not changed by, the scaling process, and aa (x.from) and a (x.to) represent the value(s) of the scaled index/ices before and after scaling.\n\nscale_with(df::DataFrame, x::Mapping)\n\nThis function scales a parameter in df according to the input map dfmap. For a parameter barz,\n\nbarz_ca = left(barz_caa circ map_aarightarrow a right)\n\nwhere c (x.constant) represents the index/ices included in, but not changed by, the scaling process, and aa (x.from) and a (x.to) represent the value(s) of the scaled index/ices before and after scaling.\n\nFor each method, x.direction = disaggregate, all disaggregate-level entries will remain equal to their aggregate-level value. If x.direction = aggregate,\n\nbarz_ca = sum_aa barz_ca\n\n\n\n\n\n","category":"function"},{"location":"api/functions/scale.html#SLiDE.compound_for!","page":"Scale","title":"SLiDE.compound_for!","text":"compound_for!(x::T, lst::AbstractArray) where T <: Scale\ncompound_for!(x::T, lst::AbstractArray, df::DataFrame) where T <: Scale\n\nThis function compounds the information in Scale for parameters scaled over multiple indices simultaneously. This is relevant for parameters such as sectoral output, ys_yrrssgg, and intermediate demand, id_yrrggss, that depend on both goods and sectors.\n\nArguments\n\nx::T where T <: Scale, scaling information over one index (ex: aa -> a), with   x.on set to the target scaling indices (ex: x.on = [:s,:g] when compounding to scale   ys_{yr,r,s,g})\nlst::AbstractArray, the complete list of disaggregate-level values in the scaling DataFrame.\ndf::DataFrame, DataFrame that will ultimately be scaled. If given, x.data will be   extended using SLiDE.map_year, to ensure that it is fully defined over all years.   This is required, for example, when using detail-level BEA data (collected every 5   years) to disaggregate summary-level data (collected annually).\n\nReturns\n\nx::T where T <: Scale,   delta_caa rightarrow a bb rightarrow b =       delta_caa rightarrow a cdot delta_c bb rightarrow b   where c (x.constant) represents the index/ices included in, but not changed by,   the scaling process, and aa,bb (x.from) and a,b (x.to) represent   the value(s) of the scaled index/ices before and after scaling.\nx.data does not include (a,b) combinations that result into one-to-one mapping.\n\nThe specifics of this calculation depend on the Scale subtype input argument.\n\ncompound_for!(x::Mapping, lst::AbstractArray)\n\nHere, all (aarightarrow a,bbrightarrow b) pairs that do not result in one-to-one mapping are included.\n\ncompound_for!(x::Weighting, lst::AbstractArray)\n\nHere, assume x.direction = disaggregate, since aggregation does not require multiplication by a weighting factor. Consider the case of sharing across both goods and sectors at once. So, g, s represent disaggregate-level goods and sectors. and gg, ss represent aggregate-level goods and sectors\n\nThis function generates a DataFrame with these sharing parameters through the following process:\n\nMultiply shares for all (ggrightarrow g,ssrightarrow s) combinations.\nAddress the case of when aggregate-level goods and sectors are the same (gg=ss):\nIf g = s, sum all of the share values.\nIf gneq s, drop these values.\n\nExample\n\nThese two examples are taken from slices of the Weighting and Mapping DataTypes compounded to scale sectoral supply, ys0(yr,r,s,g) when scaling the model parameters during the first step of the EEM build stream, executed by SLiDE.scale_sector.\n\nFirst, summary-level parameters must be disaggregated to a hybrid of summary- and detail- level data.\n\njulia> lst = [\"col_min\", \"ele_uti\", \"min\", \"oil\", \"uti\"];\n\njulia> df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"compound_for-weighting.csv\"))\n4×4 DataFrame\n│ Row │ yr    │ summary │ detail  │ value    │\n│     │ Int64 │ String  │ String  │ Float64  │\n├─────┼───────┼─────────┼─────────┼──────────┤\n│ 1   │ 2012  │ min     │ col_min │ 0.419384 │\n│ 2   │ 2012  │ min     │ min     │ 0.580616 │\n│ 3   │ 2012  │ uti     │ ele_uti │ 0.715143 │\n│ 4   │ 2012  │ uti     │ uti     │ 0.284857 │\n\njulia> weighting = Weighting(data=df, constant=[:yr], from=:summary, to=:detail, on=[:s,:g], direction=:disaggregate);\n\njulia> SLiDE.compound_for!(weighting, lst)\nWeighting(20×6 DataFrame\n│ Row │ yr     │ summary_s │ summary_g │ detail_s │ detail_g │ value    │\n│     │ Int64? │ String?   │ String?   │ String?  │ String?  │ Float64  │\n├─────┼────────┼───────────┼───────────┼──────────┼──────────┼──────────┤\n│ 1   │ 2012   │ min       │ min       │ col_min  │ col_min  │ 0.419384 │\n│ 2   │ 2012   │ min       │ min       │ min      │ min      │ 0.580616 │\n│ 3   │ 2012   │ min       │ oil       │ col_min  │ oil      │ 0.419384 │\n│ 4   │ 2012   │ min       │ oil       │ min      │ oil      │ 0.580616 │\n│ 5   │ 2012   │ min       │ uti       │ col_min  │ ele_uti  │ 0.29992  │\n│ 6   │ 2012   │ min       │ uti       │ col_min  │ uti      │ 0.119465 │\n│ 7   │ 2012   │ min       │ uti       │ min      │ ele_uti  │ 0.415223 │\n⋮\n│ 13  │ 2012   │ uti       │ min       │ ele_uti  │ col_min  │ 0.29992  │\n│ 14  │ 2012   │ uti       │ min       │ ele_uti  │ min      │ 0.415223 │\n│ 15  │ 2012   │ uti       │ min       │ uti      │ col_min  │ 0.119465 │\n│ 16  │ 2012   │ uti       │ min       │ uti      │ min      │ 0.165393 │\n│ 17  │ 2012   │ uti       │ oil       │ ele_uti  │ oil      │ 0.715143 │\n│ 18  │ 2012   │ uti       │ oil       │ uti      │ oil      │ 0.284857 │\n│ 19  │ 2012   │ uti       │ uti       │ ele_uti  │ ele_uti  │ 0.715143 │\n│ 20  │ 2012   │ uti       │ uti       │ uti      │ uti      │ 0.284857 │, [:yr], [:summary_s, :summary_g], [:detail_s, :detail_g], [:s, :g], :disaggregate)\n\nNext, these hybrid-level parameters must be aggregated in accordance with the scheme required for the EEM.\n\njulia> df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"compound_for-mapping.csv\"))\n4×2 DataFrame\n│ Row │ aggr   │ disagg  │\n│     │ String │ String  │\n├─────┼────────┼─────────┤\n│ 1   │ col    │ col_min │\n│ 2   │ eint   │ min     │\n│ 3   │ eint   │ uti     │\n│ 4   │ ele    │ ele_uti │\n\njulia> mapping = Mapping(data=df, from=:disagg, to=:aggr, on=[:s,:g], direction=:aggregate);\n\njulia> SLiDE.compound_for!(mapping, lst)\nMapping(24×4 DataFrame\n│ Row │ disagg_s │ disagg_g │ aggr_s │ aggr_g │\n│     │ String   │ String   │ String │ String │\n├─────┼──────────┼──────────┼────────┼────────┤\n│ 1   │ col_min  │ col_min  │ col    │ col    │\n│ 2   │ col_min  │ ele_uti  │ col    │ ele    │\n│ 3   │ col_min  │ min      │ col    │ eint   │\n│ 4   │ col_min  │ oil      │ col    │ oil    │\n│ 5   │ col_min  │ uti      │ col    │ eint   │\n│ 6   │ ele_uti  │ col_min  │ ele    │ col    │\n│ 7   │ ele_uti  │ ele_uti  │ ele    │ ele    │\n⋮\n│ 17  │ oil      │ ele_uti  │ oil    │ ele    │\n│ 18  │ oil      │ min      │ oil    │ eint   │\n│ 19  │ oil      │ uti      │ oil    │ eint   │\n│ 20  │ uti      │ col_min  │ eint   │ col    │\n│ 21  │ uti      │ ele_uti  │ eint   │ ele    │\n│ 22  │ uti      │ min      │ eint   │ eint   │\n│ 23  │ uti      │ oil      │ eint   │ oil    │\n│ 24  │ uti      │ uti      │ eint   │ eint   │, [:disagg_s, :disagg_g], [:aggr_s, :aggr_g], [:s, :g], :aggregate)\n\n\n\n\n\n","category":"function"},{"location":"api/functions/scale.html#SLiDE.filter_for!","page":"Scale","title":"SLiDE.filter_for!","text":"filter_for!(weighting::Weighting, lst::AbstractArray)\nfilter_for!(mapping::Mapping, weighting::Weighting)\n\nfilter_for!(mapping::Mapping, weighting::Weighting, lst::AbstractArray)\nfilter_for!(weighting::Weighting, mapping::Mapping, lst::AbstractArray)\n\n\n\n\n\n","category":"function"},{"location":"api/internals/scale.html#Build","page":"Build","title":"Build","text":"","category":"section"},{"location":"api/internals/scale.html","page":"Build","title":"Build","text":"Modules = [SLiDE]\nPages = [\"scale/scale_with.jl\"]\nPublic = false","category":"page"},{"location":"api/internals/scale.html#SLiDE._compound_with-Tuple{Weighting,DataFrames.DataFrame,DataFrames.DataFrame,Dict}","page":"Build","title":"SLiDE._compound_with","text":"Helper function to handle the differing treatment of compounding Mapping and Weighting data.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE._map_scheme-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}","page":"Build","title":"SLiDE._map_scheme","text":"_map_scheme(df, dfmap, on)\n\nInternal support for SLiDE.map_scheme to avoid confusion over DataFrame inputs.\n\nArguments\n\ndf::DataFrame of column(s) to scale\ndfmap::DataFrame of mapping columns\non::Symbol or on::Array{Symbol,1}: columns in df that will be mapped\n\nReturns\n\nfrom::Symbol or from::Array{Symbol,1}: dfmap columns that overlap with df\nto::Symbol or to::Array{Symbol,1}: dfmap columns that do not overlap with df\non::Symbol or on::Array{Symbol,1}: columns in df that will be mapped\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.compound_for!-Union{Tuple{T}, Tuple{T,AbstractArray}} where T<:Scale","page":"Build","title":"SLiDE.compound_for!","text":"compound_for!(x::T, lst::AbstractArray) where T <: Scale\ncompound_for!(x::T, lst::AbstractArray, df::DataFrame) where T <: Scale\n\nThis function compounds the information in Scale for parameters scaled over multiple indices simultaneously. This is relevant for parameters such as sectoral output, ys_yrrssgg, and intermediate demand, id_yrrggss, that depend on both goods and sectors.\n\nArguments\n\nx::T where T <: Scale, scaling information over one index (ex: aa -> a), with   x.on set to the target scaling indices (ex: x.on = [:s,:g] when compounding to scale   ys_{yr,r,s,g})\nlst::AbstractArray, the complete list of disaggregate-level values in the scaling DataFrame.\ndf::DataFrame, DataFrame that will ultimately be scaled. If given, x.data will be   extended using SLiDE.map_year, to ensure that it is fully defined over all years.   This is required, for example, when using detail-level BEA data (collected every 5   years) to disaggregate summary-level data (collected annually).\n\nReturns\n\nx::T where T <: Scale,   delta_caa rightarrow a bb rightarrow b =       delta_caa rightarrow a cdot delta_c bb rightarrow b   where c (x.constant) represents the index/ices included in, but not changed by,   the scaling process, and aa,bb (x.from) and a,b (x.to) represent   the value(s) of the scaled index/ices before and after scaling.\nx.data does not include (a,b) combinations that result into one-to-one mapping.\n\nThe specifics of this calculation depend on the Scale subtype input argument.\n\ncompound_for!(x::Mapping, lst::AbstractArray)\n\nHere, all (aarightarrow a,bbrightarrow b) pairs that do not result in one-to-one mapping are included.\n\ncompound_for!(x::Weighting, lst::AbstractArray)\n\nHere, assume x.direction = disaggregate, since aggregation does not require multiplication by a weighting factor. Consider the case of sharing across both goods and sectors at once. So, g, s represent disaggregate-level goods and sectors. and gg, ss represent aggregate-level goods and sectors\n\nThis function generates a DataFrame with these sharing parameters through the following process:\n\nMultiply shares for all (ggrightarrow g,ssrightarrow s) combinations.\nAddress the case of when aggregate-level goods and sectors are the same (gg=ss):\nIf g = s, sum all of the share values.\nIf gneq s, drop these values.\n\nExample\n\nThese two examples are taken from slices of the Weighting and Mapping DataTypes compounded to scale sectoral supply, ys0(yr,r,s,g) when scaling the model parameters during the first step of the EEM build stream, executed by SLiDE.scale_sector.\n\nFirst, summary-level parameters must be disaggregated to a hybrid of summary- and detail- level data.\n\njulia> lst = [\"col_min\", \"ele_uti\", \"min\", \"oil\", \"uti\"];\n\njulia> df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"compound_for-weighting.csv\"))\n4×4 DataFrame\n│ Row │ yr    │ summary │ detail  │ value    │\n│     │ Int64 │ String  │ String  │ Float64  │\n├─────┼───────┼─────────┼─────────┼──────────┤\n│ 1   │ 2012  │ min     │ col_min │ 0.419384 │\n│ 2   │ 2012  │ min     │ min     │ 0.580616 │\n│ 3   │ 2012  │ uti     │ ele_uti │ 0.715143 │\n│ 4   │ 2012  │ uti     │ uti     │ 0.284857 │\n\njulia> weighting = Weighting(data=df, constant=[:yr], from=:summary, to=:detail, on=[:s,:g], direction=:disaggregate);\n\njulia> SLiDE.compound_for!(weighting, lst)\nWeighting(20×6 DataFrame\n│ Row │ yr     │ summary_s │ summary_g │ detail_s │ detail_g │ value    │\n│     │ Int64? │ String?   │ String?   │ String?  │ String?  │ Float64  │\n├─────┼────────┼───────────┼───────────┼──────────┼──────────┼──────────┤\n│ 1   │ 2012   │ min       │ min       │ col_min  │ col_min  │ 0.419384 │\n│ 2   │ 2012   │ min       │ min       │ min      │ min      │ 0.580616 │\n│ 3   │ 2012   │ min       │ oil       │ col_min  │ oil      │ 0.419384 │\n│ 4   │ 2012   │ min       │ oil       │ min      │ oil      │ 0.580616 │\n│ 5   │ 2012   │ min       │ uti       │ col_min  │ ele_uti  │ 0.29992  │\n│ 6   │ 2012   │ min       │ uti       │ col_min  │ uti      │ 0.119465 │\n│ 7   │ 2012   │ min       │ uti       │ min      │ ele_uti  │ 0.415223 │\n⋮\n│ 13  │ 2012   │ uti       │ min       │ ele_uti  │ col_min  │ 0.29992  │\n│ 14  │ 2012   │ uti       │ min       │ ele_uti  │ min      │ 0.415223 │\n│ 15  │ 2012   │ uti       │ min       │ uti      │ col_min  │ 0.119465 │\n│ 16  │ 2012   │ uti       │ min       │ uti      │ min      │ 0.165393 │\n│ 17  │ 2012   │ uti       │ oil       │ ele_uti  │ oil      │ 0.715143 │\n│ 18  │ 2012   │ uti       │ oil       │ uti      │ oil      │ 0.284857 │\n│ 19  │ 2012   │ uti       │ uti       │ ele_uti  │ ele_uti  │ 0.715143 │\n│ 20  │ 2012   │ uti       │ uti       │ uti      │ uti      │ 0.284857 │, [:yr], [:summary_s, :summary_g], [:detail_s, :detail_g], [:s, :g], :disaggregate)\n\nNext, these hybrid-level parameters must be aggregated in accordance with the scheme required for the EEM.\n\njulia> df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"compound_for-mapping.csv\"))\n4×2 DataFrame\n│ Row │ aggr   │ disagg  │\n│     │ String │ String  │\n├─────┼────────┼─────────┤\n│ 1   │ col    │ col_min │\n│ 2   │ eint   │ min     │\n│ 3   │ eint   │ uti     │\n│ 4   │ ele    │ ele_uti │\n\njulia> mapping = Mapping(data=df, from=:disagg, to=:aggr, on=[:s,:g], direction=:aggregate);\n\njulia> SLiDE.compound_for!(mapping, lst)\nMapping(24×4 DataFrame\n│ Row │ disagg_s │ disagg_g │ aggr_s │ aggr_g │\n│     │ String   │ String   │ String │ String │\n├─────┼──────────┼──────────┼────────┼────────┤\n│ 1   │ col_min  │ col_min  │ col    │ col    │\n│ 2   │ col_min  │ ele_uti  │ col    │ ele    │\n│ 3   │ col_min  │ min      │ col    │ eint   │\n│ 4   │ col_min  │ oil      │ col    │ oil    │\n│ 5   │ col_min  │ uti      │ col    │ eint   │\n│ 6   │ ele_uti  │ col_min  │ ele    │ col    │\n│ 7   │ ele_uti  │ ele_uti  │ ele    │ ele    │\n⋮\n│ 17  │ oil      │ ele_uti  │ oil    │ ele    │\n│ 18  │ oil      │ min      │ oil    │ eint   │\n│ 19  │ oil      │ uti      │ oil    │ eint   │\n│ 20  │ uti      │ col_min  │ eint   │ col    │\n│ 21  │ uti      │ ele_uti  │ eint   │ ele    │\n│ 22  │ uti      │ min      │ eint   │ eint   │\n│ 23  │ uti      │ oil      │ eint   │ oil    │\n│ 24  │ uti      │ uti      │ eint   │ eint   │, [:disagg_s, :disagg_g], [:aggr_s, :aggr_g], [:s, :g], :aggregate)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.compound_for-Union{Tuple{T}, Tuple{T,AbstractArray,DataFrames.DataFrame}} where T<:Scale","page":"Build","title":"SLiDE.compound_for","text":"compound_for(x::T, lst::AbstractArray, df::DataFrame)\ncompound_for(x::T, lst::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.drop_identity-Tuple{DataFrames.DataFrame,Array{Symbol,1}}","page":"Build","title":"SLiDE.drop_identity","text":"This function drops df rows that are mapped one-to-one.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.filter_for!-Tuple{Weighting,AbstractArray}","page":"Build","title":"SLiDE.filter_for!","text":"filter_for!(weighting::Weighting, lst::AbstractArray)\nfilter_for!(mapping::Mapping, weighting::Weighting)\n\nfilter_for!(mapping::Mapping, weighting::Weighting, lst::AbstractArray)\nfilter_for!(weighting::Weighting, mapping::Mapping, lst::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.find_sector-Tuple{AbstractArray}","page":"Build","title":"SLiDE.find_sector","text":"Argument\n\nidx::AbstractArray: list of columns that might contain good/sector indices OR   df::DataFrame: for which we need to find goods/sectors\n\nReturns\n\nidx::Array{Symbol,1}: input columns that overlap with [:g,:s] in the order in which   they're given\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.has_scheme-Tuple{T} where T<:Scale","page":"Build","title":"SLiDE.has_scheme","text":"This function returns true if all scaling parameters have been set to a defined parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.list_unique-Tuple{DataFrames.DataFrame}","page":"Build","title":"SLiDE.list_unique","text":"list_unique(df::DataFrame)\nlist_unique(df::DataFrame, idx::AbstractArray)\nlist_unique(df::DataFrame, idx::Symbol)\n\nThis function returns a list of all unique elements across multiple DataFrame columns\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.map_direction-Tuple{DataFrames.DataFrame}","page":"Build","title":"SLiDE.map_direction","text":"map_direction(df::DataFrame)\nmap_direction(x::T) where T <: Scale\n\nThis function returns a Tuple of DataFrame columns in the order (aggregate, disaggregate). This is determined from the number of unique entries in each column under the assumption that the aggregate-level will have fewer unique entries.\n\ndf = DataFrame(s=\"cng\", src=[\"cru\",\"gas\"])\nSLiDE.map_direction(df)\n\n# output\n\n(:s, :src)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.map_identity-Tuple{Mapping,AbstractArray}","page":"Build","title":"SLiDE.map_identity","text":"map_identity(x::T, lst::AbstractArray) where T<:Scale\n\nThis function adds one-to-one mapping to the data field in Mapping or Weighting so that the entirity of lst is included in the mapping.\n\nReturns\n\ndf::DataFrame with lst completely mapped.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.map_scheme-Tuple{Weighting,Mapping}","page":"Build","title":"SLiDE.map_scheme","text":"map_scheme(x::T...)\nmap_scheme(x::T, df::DataFrame)\n\nThis function sets the direction field for Mapping and Weighting types based on overlap between input parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.reverse_scheme!-Tuple{T} where T<:Scale","page":"Build","title":"SLiDE.reverse_scheme!","text":"\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.scale_with-Tuple{DataFrames.DataFrame,Weighting}","page":"Build","title":"SLiDE.scale_with","text":"scale_with(df::DataFrame, x::Weighting)\n\nThis function maps df: x.from -> x.to, multiplying by any associated share specified in x.data. For a parameter barz,\n\nbeginaligned\nbarz_ca = sum_aa left( barz_caa cdot tildedelta_caa rightarrow a right)\nendaligned\n\nwhere c (x.constant) represents the index/ices included in, but not changed by, the scaling process, and aa (x.from) and a (x.to) represent the value(s) of the scaled index/ices before and after scaling.\n\nscale_with(df::DataFrame, x::Mapping)\n\nThis function scales a parameter in df according to the input map dfmap. For a parameter barz,\n\nbarz_ca = left(barz_caa circ map_aarightarrow a right)\n\nwhere c (x.constant) represents the index/ices included in, but not changed by, the scaling process, and aa (x.from) and a (x.to) represent the value(s) of the scaled index/ices before and after scaling.\n\nFor each method, x.direction = disaggregate, all disaggregate-level entries will remain equal to their aggregate-level value. If x.direction = aggregate,\n\nbarz_ca = sum_aa barz_ca\n\n\n\n\n\n","category":"method"},{"location":"api/internals/scale.html#SLiDE.set_scheme!-Tuple{Weighting,Mapping}","page":"Build","title":"SLiDE.set_scheme!","text":"set_scheme!(mapping::Mapping)\n\nDefine Mapping and/or Weighting fields from and to if direction is already defined.\n\nset_scheme!(mapping::Mapping, weighting::Weighting)\nset_scheme!(weighting::Weighting, mapping::Mapping)\n\nDefines Mapping and/or Weighting fields from and to !!!!\n\n\n\n\n\n","category":"method"},{"location":"api/types/cge.html#CGE","page":"CGE","title":"CGE","text":"","category":"section"},{"location":"api/types/cge.html","page":"CGE","title":"CGE","text":"Modules = [SLiDE]\nPrivate = false\nFilter = t -> t <: SLiDE.CGE\nOrder = [:type]","category":"page"},{"location":"api/types/cge.html#SLiDE.Dataset","page":"CGE","title":"SLiDE.Dataset","text":"mutable struct Dataset <: CGE\n    name::String\n    build::String\n    step::String\n    sector_level::Symbol\n    eem::Bool\n    save_build::Bool\n    overwrite::Bool\nend\n\nArguments\n\nname::String: dataset identifier\nbuild::String: Current step of the buildstream process: io or eem\nstep::String: Current substep of the buildstream. If build=io, these steps are partition, calibrate, share, disaggregate. If build=eem, these steps are ...\nsector_level::Symbol: Aggregation level to use when reading BEA supply/use data.\neem::Bool: Flag indicating whether to include the Energy-Environment module. If eem=true, first build io supply/use data. Then build eem data.\nsave_build::Bool: Flag indicating decides whether to save the information at each build step. Setting save_build=true will add directories in the locations returned by SLiDE.datapath. This feature is particularly helpful for buildstream debugging.\noverwrite::Bool: If data exists, do not read it. Build the data from scratch.\n\n\n\n\n\n","category":"type"},{"location":"api/types/cge.html#SLiDE.Parameter","page":"CGE","title":"SLiDE.Parameter","text":"mutable struct Parameter <: CGE\n    parameter::Symbol\n    name::String\n    index::Array{Symbol,1}\n    units::String\nend\n\nInformation about CGE parameters used in the model.\n\nArguments\n\nparameter::Symbol: parameter variable abbreviation\nname::String: parameter description\nindex::Array{Symbol,1}: Sets on which the parameter depends\nunits::String: parameter units\n\n\n\n\n\n","category":"type"},{"location":"man/build/overview.html#Build","page":"Overview","title":"Build","text":"","category":"section"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"The buildstream process and all of the notation included in the SLiDE documentation here is meant to replicate the WiNDC buildstream. For more information, please reference:","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"Thomas F. Rutherford and Andrew Schreiber, \"Tools for Open Source, Subnational CGE   Modeling with an Illustrative Analysis of Carbon Leakage,\"   J Global Econ Anal 4(2): 1-66.","category":"page"},{"location":"man/build/overview.html#Input","page":"Overview","title":"Input","text":"","category":"section"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"Build stream preferences can be specified using the SLiDE.Dataset input type.","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"name::String: dataset identifier. Data produced by the build stream will be saved in   the directory data/<name>. If no name is specified, state_model will be used.","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"The following options can be specified using keyword arguments.","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"overwrite::Bool. Would you like to overwrite the existing dataset with this name?   If set to true, the existing directory will be renamed.\neem::Bool. Would you like to build the Energy-Environment Module?   By default, this is set to false.","category":"page"},{"location":"man/build/overview.html#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"Build model data, using the default name and all default options:","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"d, set = build()","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"Build model data, using the default name but enabling the Energy-Environment Module.","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"d, set = build( ; eem=true)","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"Build model data, naming the dataset slug_trails and using all default options:","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"d, set = build(\"slug_trails\")","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"Build model data, naming the dataset slug_trails and overwriting the previous slug_trails dataset:","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"d, set = build(\"slug_trails\"; overwrite=true)","category":"page"},{"location":"man/build/overview.html#Process","page":"Overview","title":"Process","text":"","category":"section"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"The buildstream is executed using the build function.","category":"page"},{"location":"man/build/overview.html","page":"Overview","title":"Overview","text":"build\nSLiDE.build_io\nSLiDE.build_eem","category":"page"},{"location":"man/build/overview.html#SLiDE.build","page":"Overview","title":"SLiDE.build","text":"build(dataset::Dataset)\n\nThis function executes the SLiDE buildstream and generates the parameters necessary to run the model. If the dataset has already been generated and saved, the function will read and return those values. Otherwise, it will generate these parameters by executing:\n\nSLiDE.build_io\nSLiDE.build_eem – if dataset.eem=true\n\n\n\n\n\n","category":"function"},{"location":"man/build/overview.html#SLiDE.build_io","page":"Overview","title":"SLiDE.build_io","text":"build_io(dataset::Dataset)\n\nIf the dataset has already been generated and saved, the function will read and return those values.\n\nOtherwise, it will read input data from the /SLIDE_DIR/data/input/ directory and execute the four steps of the SLiDE buildstream via the following functions:\n\nSLiDE.partition_bea\nSLiDE.calibrate_national\nSLiDE.share_region\nSLiDE.disaggregate_region\n\nArguments\n\ndataset::Dataset identifier\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/overview.html#SLiDE.build_eem","page":"Overview","title":"SLiDE.build_eem","text":"build_eem(dataset::Dataset)\n\nIf dataset.eem=true, continue the SLiDE buildstream for the Energy-Environment Module. If the dataset has already been generated and saved, the function will read and return those values.\n\nOtherwise, it will execute the build routine via the following functions:\n\nSLiDE.scale_sector\nSLiDE.partition_seds\nSLiDE.disaggregate_energy!\nSLiDE.partition_co2!\nSLiDE.calibrate_regional\n\nArguments\n\ndataset::Dataset identifier\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Partition:-BEA-Make-Use","page":"Partition: BEA","title":"Partition: BEA Make-Use","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"The first step in the build stream involves partitioning BEA supply/use data into parameters by filtering this data based on sectors and goods. Generally, BEA input (i) maps to goods (g), and BEA output (j) maps to sectors (s).","category":"page"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE.partition_bea","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE.partition_bea","page":"Partition: BEA","title":"SLiDE.partition_bea","text":"partition_bea(dataset::Dataset, d::Dict, set::Dict; kwargs...)\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_io!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_io!","page":"Partition: BEA","title":"SLiDE._partition_io!","text":"ys0(yr,s,g), sectoral supply (with byproducts), and id0(yr,g,s), intermediate input demand\n\nFilter from supply/use data:\n\nbeginaligned\ntildeid_yrs = leftuseleft(yrijright)\nvert yr g in i s in j right\n\ntildeys_yrsg = leftsupplyleft(yrjiright)\nvert yr s in j g in i right\nendaligned\n\nTreat negative inputs as outputs:\n\nbeginaligned\ntildeys_yrsg = tildeys_yrsg - minleft0 tildeid_yrgs right \ntildeid_yrgs = maxleft 0 tildeid_yrsg right\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Use","page":"Partition: BEA","title":"Use","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_ts0!\nSLiDE._partition_va0!\nSLiDE._partition_x0!\nSLiDE._partition_fd!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_ts0!","page":"Partition: BEA","title":"SLiDE._partition_ts0!","text":"ts(yr,ts,s), taxes and subsidies\n\ntildets_yrtss = leftuseleft(yrijright)\nvert yr ts in i s in j right\n\nTreat negative inputs as outputs:\n\ntildets_yrtss = - tildets_yrtss\nforall ts = subsidies\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_va0!","page":"Partition: BEA","title":"SLiDE._partition_va0!","text":"va(yr,va,s), value added\n\ntildeva_yrvas = leftuseleft(yrijright)\nvert yr va in i s in j right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_x0!","page":"Partition: BEA","title":"SLiDE._partition_x0!","text":"x(yr,g), exports of goods and services\n\ntildex_yrg = leftuseleft(yrijright)\nvert yr g in i exports in j right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_fd!","page":"Partition: BEA","title":"SLiDE._partition_fd!","text":"fd(yr,g,fd), final demand, and fs(yr,g), household supply\n\nbeginaligned\ntildefd_yrgfd = leftuseleft(yrijright) vert yr g in i fd in j right\n\ntildefs_yrg = lefttildefd_yrgfd vert yr g in i fd = pce right\nendaligned\n\nbeginaligned\ntildefs_yrg = - minleft0 tildefs_yrg right\n\ntildefd_yrgfd = maxleft0 tildefd_yrgfd right\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Calculate-aggregates","page":"Partition: BEA","title":"Calculate aggregates","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_s0!\nSLiDE._partition_a0!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_s0!","page":"Partition: BEA","title":"SLiDE._partition_s0!","text":"s(yr,s), aggregate supply\n\ntildes_yrs = sum_gtildeys_yrsg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_a0!","page":"Partition: BEA","title":"SLiDE._partition_a0!","text":"a(yr,g), Armington supply\n\ntildea_yrg = sum_fdtildefd_yrgfd + sum_stildeid_yrgs\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Supply","page":"Partition: BEA","title":"Supply","text":"","category":"section"},{"location":"man/build/io/partition_bea.html#Make-insurance-adjustments.","page":"Partition: BEA","title":"Make insurance adjustments.","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_cif0!\nSLiDE._partition_m0!\nSLiDE._partition_trn0!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_cif0!","page":"Partition: BEA","title":"SLiDE._partition_cif0!","text":"cif(yr,g), CIF/FOB Adjustments on Imports\n\ntildecif_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = ciffob right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_m0!","page":"Partition: BEA","title":"SLiDE._partition_m0!","text":"m(yr,g), imports\n\ntildem_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = imports right\n\nAdjust transport margins according to CIF/FOB adjustments:\n\ntildem_yrg = tildem_yrg + tildecif_yrg\nforall g = ins\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_trn0!","page":"Partition: BEA","title":"SLiDE._partition_trn0!","text":"trn(yr,g), transportation costs\n\ntildetrn_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = trncost right\n\ntildetrn_yrg = tildem_yrg + tildecif_yrg\nforall g neq ins\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Calculate-margin-supply-and-demand.","page":"Partition: BEA","title":"Calculate margin supply and demand.","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_mrg0!\nSLiDE._partition_md0!\nSLiDE._partition_ms0!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_mrg0!","page":"Partition: BEA","title":"SLiDE._partition_mrg0!","text":"mrg(yr,g), trade margins\n\ntildemrg_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = margins right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_md0!","page":"Partition: BEA","title":"SLiDE._partition_md0!","text":"md(yr,m,g), margin demand\n\nbeginaligned\ntildemd_yrmg = \nbegincases\ntildemrg_yrg   m = trd   \ntildetrn_yrg   m = trn\nendcases\n\ntildemd_yrmg = maxleft0 tildemd_yrmg right\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_ms0!","page":"Partition: BEA","title":"SLiDE._partition_ms0!","text":"ms(yr,g,m), margin supply\n\nbeginaligned\ntildems_yrgm = \nbegincases\ntildemrg_yrg   m = trd   \ntildetrn_yrg   m = trn\nendcases\n\ntildems_yrgm = maxleft0 -tildems_yrgm right\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_y0!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_y0!","page":"Partition: BEA","title":"SLiDE._partition_y0!","text":"y(yr,g), gross output \"Move household supply of recycled goods into the domestic output market from which some may be exported. Net out margin supply from output.\"\n\ntildey_yrg = sum_stildeys_yrsg + tildefd_yrg - sum_mtildems_yrgm\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Calculate-import-tariffs.","page":"Partition: BEA","title":"Calculate import tariffs.","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_tax0!\nSLiDE._partition_sbd0!\nSLiDE._partition_ta0!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_tax0!","page":"Partition: BEA","title":"SLiDE._partition_tax0!","text":"tax(yr,g), taxes on products\n\ntildetax_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = tax right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_sbd0!","page":"Partition: BEA","title":"SLiDE._partition_sbd0!","text":"sbd(yr,g), subsidies on products\n\ntildesbd_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = subsidies right\n\nTreat negative inputs as outputs:\n\ntildesbd_yrg = - tildesbd_yrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_ta0!","page":"Partition: BEA","title":"SLiDE._partition_ta0!","text":"ta(yr,g), import tariff\n\ntildeta_yrg = fractildetax_yrg - tildesbd_yrgtildea_yrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#Calculate-tax-rate-on-intermediate-demand.","page":"Partition: BEA","title":"Calculate tax rate on intermediate demand.","text":"","category":"section"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_duty0!\nSLiDE._partition_tm0!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_duty0!","page":"Partition: BEA","title":"SLiDE._partition_duty0!","text":"duty(yr,g), import duties\n\ntildeduty_yrg = leftsupplyleft(yrijright)\nvert yr g in i j = duties right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_tm0!","page":"Partition: BEA","title":"SLiDE._partition_tm0!","text":"tm(yr,g), tax net subsidy rate on intermediate demand\n\ntildetm_yrg = fractildeduty_yrgtildem_yrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/partition_bea.html","page":"Partition: BEA","title":"Partition: BEA","text":"SLiDE._partition_bop!","category":"page"},{"location":"man/build/io/partition_bea.html#SLiDE._partition_bop!","page":"Partition: BEA","title":"SLiDE._partition_bop!","text":"bopdef(yr), balance of payments\n\ntildebop_yr = 0\nforall yr\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#Regional-Sharing","page":"Regional Sharing","title":"Regional Sharing","text":"","category":"section"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"Divide data into regional component. This will guide how to break the national data into regional components by state or county.","category":"page"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"SLiDE.share_region","category":"page"},{"location":"man/build/io/share_region.html#SLiDE.share_region","page":"Regional Sharing","title":"SLiDE.share_region","text":"share_region(d::Dict, set::Dict; save_build = true, overwrite = false)\n\nThis function partitions BEA and Census Bureau data to use when disaggregating parameters from the national- to regional-level.\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#CFS","page":"Regional Sharing","title":"CFS","text":"","category":"section"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"SLiDE.share_rpc!\nSLiDE._share_mrt0!\nSLiDE._share_d0!\nSLiDE._share_xn0!\nSLiDE._share_mn0!\nSLiDE._avg_ng","category":"page"},{"location":"man/build/io/share_region.html#SLiDE.share_rpc!","page":"Regional Sharing","title":"SLiDE.share_rpc!","text":"rpc(r,g): Regional purchase coefficient\n\nrho_rg^cfs\n=\nbegincases\ndfracbard_rg\n       bard_rg - barmn_rg   rneq uti bard_rg neq barmn_rg\n\n00                                         rneq uti bard_rg = barmn_rg\n\n09                                         r = uti\nendcases\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#SLiDE._share_mrt0!","page":"Regional Sharing","title":"SLiDE._share_mrt0!","text":"mrt0(orig,dest,g): Interstate trade (CFS)\n\nbarmrt_origdestngni g = leftcfsleft(origdestgright)\nvert origneq dest  g right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#SLiDE._share_d0!","page":"Regional Sharing","title":"SLiDE._share_d0!","text":"d0(r,g): Local supply-demand (CFS), trade that remains within the same region.\n\nbard_rngni g = leftcfsleft(origdestgright)\nvert orig=dest  g right\n\nCalling SLiDE._avg_ng returns bard_rngin g.\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#SLiDE._share_xn0!","page":"Regional Sharing","title":"SLiDE._share_xn0!","text":"xn0(r,g): National exports (CFS)\n\nbarxn_rngni g = sum_dest barmrt_origdestngni g\n\nCalling SLiDE._avg_ng returns barxn_rngin g.\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#SLiDE._share_mn0!","page":"Regional Sharing","title":"SLiDE._share_mn0!","text":"mn0(r,g): National demand (CFS)\n\nbarmn_rngni g = sum_orig barmrt_origdestngni g\n\nCalling SLiDE._avg_ng returns barmn_rngin g.\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#SLiDE._avg_ng","page":"Regional Sharing","title":"SLiDE._avg_ng","text":"barx_rngin g = dfracsum_g barx_rg\n    textlength(ng)\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#GSP","page":"Regional Sharing","title":"GSP","text":"","category":"section"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"SLiDE.share_region!","category":"page"},{"location":"man/build/io/share_region.html#SLiDE.share_region!","page":"Regional Sharing","title":"SLiDE.share_region!","text":"region(yr,r,s): Regional share of value added\n\nalpha_yrrs^gsp\n=\nbegincases\ndfrac           bargdp_yrrs\n       sum_s bargdp_yrrs       sum_s bargdp_yrrs neq 0\n\ndfracsum_s    bargdp_yrr s\n       sum_rs bargdp_yrrs     sum_s bargdp_yrrs = 0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#PCE","page":"Regional Sharing","title":"PCE","text":"","category":"section"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"SLiDE.share_pce!","category":"page"},{"location":"man/build/io/share_region.html#SLiDE.share_pce!","page":"Regional Sharing","title":"SLiDE.share_pce!","text":"pce(yr,r,g): Regional shares of final consumption\n\nalpha_yrrg^pce = dfracbarpce_yrrgsum_r barpce_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#SGF","page":"Regional Sharing","title":"SGF","text":"","category":"section"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"SLiDE.share_sgf!","category":"page"},{"location":"man/build/io/share_region.html#SLiDE.share_sgf!","page":"Regional Sharing","title":"SLiDE.share_sgf!","text":"sgf(yr,r,g): State Government Finance data.\n\nalpha_yrrg^sgf = dfracbarsgf_yrrgsum_r barsgf_yrrg\n\nNote: D.C. is not included in the original data set. Assume its SGF data is equal to Maryland's.\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/share_region.html#UTD","page":"Regional Sharing","title":"UTD","text":"","category":"section"},{"location":"man/build/io/share_region.html","page":"Regional Sharing","title":"Regional Sharing","text":"SLiDE.share_utd!","category":"page"},{"location":"man/build/io/share_region.html#SLiDE.share_utd!","page":"Regional Sharing","title":"SLiDE.share_utd!","text":"utd(yr,r,g,t): Share of total trade by region.\n\nalpha_yrrgt^utd\n=\nbegincases\ndfrac           barutd_yrr gt\n       sum_r barutd_yrrgt         notrdni g\n\ndfracsum_yr    barutd_yrr gt\n       sum_yrr barutd_yrrgt    notrdin g\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/functions/filter.html#Filter-and-Resize","page":"Filter and Resize","title":"Filter and Resize","text":"","category":"section"},{"location":"api/functions/filter.html#Filter","page":"Filter and Resize","title":"Filter","text":"","category":"section"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"filter_with\nextrapolate_year\nextrapolate_region","category":"page"},{"location":"api/functions/filter.html#SLiDE.filter_with","page":"Filter and Resize","title":"SLiDE.filter_with","text":"filter_with(df::DataFrame, set::Any; kwargs...)\n\nArguments\n\ndf::DataFrame to filter.\nset::Dict or set::NamedTuple: Values to keep in the DataFrame.\n\nKeywords\n\nextrapolate::Bool = false: Add missing regions/years to the DataFrame?   If extrapolate is set to true, the following kwargs become relevant:\nWhen extrapolating over years,\nbackward::Bool = true: Do we extrapolate backward in time?\nforward::Bool = true: Do we extrapolate forward in time?\nCurrently, \"extrapolating\" means copying the closest \nWhen extrapolating across regions,\nr::Pair = \"md\" => \"dc: Pair indicating a region (r.first) to extrapolate to   another region (r.second). A suggested regional extrapolation: MD data will be   used to approximate DC data in the event that it is missing.\noverwrite::Bool = false: If data in the target region r.second is already present,   should it be overwritten?\n\nReturns\n\ndf::DataFrame with only the desired keys.\n\nExamples\n\njulia> df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"filter_use.csv\"))\n14×4 DataFrame\n│ Row │ yr    │ i      │ j      │ value   │\n│     │ Int64 │ String │ String │ Float64 │\n├─────┼───────┼────────┼────────┼─────────┤\n│ 1   │ 2015  │ agr    │ agr    │ 69.42   │\n│ 2   │ 2015  │ agr    │ fbp    │ 277.179 │\n│ 3   │ 2015  │ fbp    │ agr    │ 49.132  │\n│ 4   │ 2015  │ fbp    │ fbp    │ 210.998 │\n│ 5   │ 2015  │ uti    │ agr    │ 4.846   │\n│ 6   │ 2015  │ uti    │ fbp    │ 10.102  │\n│ 7   │ 2015  │ uti    │ uti    │ 35.093  │\n│ 8   │ 2016  │ agr    │ agr    │ 60.197  │\n│ 9   │ 2016  │ agr    │ fbp    │ 264.173 │\n│ 10  │ 2016  │ fbp    │ agr    │ 47.739  │\n│ 11  │ 2016  │ fbp    │ fbp    │ 205.21  │\n│ 12  │ 2016  │ uti    │ agr    │ 4.548   │\n│ 13  │ 2016  │ uti    │ fbp    │ 9.152   │\n│ 14  │ 2016  │ uti    │ uti    │ 27.47   │\n\njulia> df = filter_with(df, (i = [\"agr\",\"fbp\"], j = [\"agr\",\"fbp\"]))\n8×4 DataFrame\n│ Row │ yr    │ i      │ j      │ value   │\n│     │ Int64 │ String │ String │ Float64 │\n├─────┼───────┼────────┼────────┼─────────┤\n│ 1   │ 2015  │ agr    │ agr    │ 69.42   │\n│ 2   │ 2015  │ agr    │ fbp    │ 277.179 │\n│ 3   │ 2015  │ fbp    │ agr    │ 49.132  │\n│ 4   │ 2015  │ fbp    │ fbp    │ 210.998 │\n│ 5   │ 2016  │ agr    │ agr    │ 60.197  │\n│ 6   │ 2016  │ agr    │ fbp    │ 264.173 │\n│ 7   │ 2016  │ fbp    │ agr    │ 47.739  │\n│ 8   │ 2016  │ fbp    │ fbp    │ 205.21  │\n\njulia> filter_with(df, (yr = 2016,); drop = true)\n4×3 DataFrame\n│ Row │ i      │ j      │ value   │\n│     │ String │ String │ Float64 │\n├─────┼────────┼────────┼─────────┤\n│ 1   │ agr    │ agr    │ 60.197  │\n│ 2   │ agr    │ fbp    │ 264.173 │\n│ 3   │ fbp    │ agr    │ 47.739  │\n│ 4   │ fbp    │ fbp    │ 205.21  │\n\n\n\n\n\n","category":"function"},{"location":"api/functions/filter.html#SLiDE.extrapolate_year","page":"Filter and Resize","title":"SLiDE.extrapolate_year","text":"extrapolate_year(df::DataFrame, yr::Array{Int64,1}; kwargs...)\nextrapolate_year(df::DataFrame, set::Any; kwargs...)\n\nArguments\n\ndf::DataFrame that might be in need of extrapolation.\nyr::Array{Int64,1}: List of years overwhich extrapolation is possible (depending on the kwargs)\nset::Dict or set::NamedTuple containing list of years, identified by the key :yr.\n\nKeywords\n\nbackward::Bool = true: Do we extrapolate backward in time?\nforward::Bool = true: Do we extrapolate forward in time?\n\nReturns\n\ndf::DataFrame extrapolated in time.\n\nExample\n\nContinuing with the DataFrame from SLiDE.filter_with,\n\njulia> df\n8×4 DataFrame\n│ Row │ yr    │ i      │ j      │ value   │\n│     │ Int64 │ String │ String │ Float64 │\n├─────┼───────┼────────┼────────┼─────────┤\n│ 1   │ 2015  │ agr    │ agr    │ 69.42   │\n│ 2   │ 2015  │ agr    │ fbp    │ 277.179 │\n│ 3   │ 2015  │ fbp    │ agr    │ 49.132  │\n│ 4   │ 2015  │ fbp    │ fbp    │ 210.998 │\n│ 5   │ 2016  │ agr    │ agr    │ 60.197  │\n│ 6   │ 2016  │ agr    │ fbp    │ 264.173 │\n│ 7   │ 2016  │ fbp    │ agr    │ 47.739  │\n│ 8   │ 2016  │ fbp    │ fbp    │ 205.21  │\n\njulia> extrapolate_year(df, Dict(:yr => 2014:2017))\n16×4 DataFrame\n│ Row │ yr    │ i      │ j      │ value   │\n│     │ Int64 │ String │ String │ Float64 │\n├─────┼───────┼────────┼────────┼─────────┤\n│ 1   │ 2014  │ agr    │ agr    │ 69.42   │\n│ 2   │ 2014  │ agr    │ fbp    │ 277.179 │\n│ 3   │ 2014  │ fbp    │ agr    │ 49.132  │\n│ 4   │ 2014  │ fbp    │ fbp    │ 210.998 │\n│ 5   │ 2015  │ agr    │ agr    │ 69.42   │\n│ 6   │ 2015  │ agr    │ fbp    │ 277.179 │\n│ 7   │ 2015  │ fbp    │ agr    │ 49.132  │\n│ 8   │ 2015  │ fbp    │ fbp    │ 210.998 │\n│ 9   │ 2016  │ agr    │ agr    │ 60.197  │\n│ 10  │ 2016  │ agr    │ fbp    │ 264.173 │\n│ 11  │ 2016  │ fbp    │ agr    │ 47.739  │\n│ 12  │ 2016  │ fbp    │ fbp    │ 205.21  │\n│ 13  │ 2017  │ agr    │ agr    │ 60.197  │\n│ 14  │ 2017  │ agr    │ fbp    │ 264.173 │\n│ 15  │ 2017  │ fbp    │ agr    │ 47.739  │\n│ 16  │ 2017  │ fbp    │ fbp    │ 205.21  │\n\n\n\n\n\n","category":"function"},{"location":"api/functions/filter.html#SLiDE.extrapolate_region","page":"Filter and Resize","title":"SLiDE.extrapolate_region","text":"extrapolate_region(df::DataFrame; kwargs...)\nextrapolate_region(df::DataFrame, r::Pair; kwargs...)\n\nFills in missing data in the input DataFrame df by filling it with existing information in df. Here, \"extrapolate\" makes a direct copy of the data.\n\nArguments\n\ndf::DataFrame that might be in need of extrapolation.\nr::Pair = \"md\" => \"dc: Pair indicating a region (r.first) to extrapolate to another   region (r.second). A suggested regional extrapolation: MD data will be used to   approximate DC data in the event that it is missing. To fill multiple regions with data,   use \"md\" => [\"dc\",\"va\"].\n\nKeyword Argument:\n\noverwrite::Bool = false: If data in the target region r.second is already present,   should it be overwritten?\n\nReturns\n\ndf::DataFrame extrapolated in region.\n\nExample\n\njulia> df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"filter_utd.csv\"))\n8×5 DataFrame\n│ Row │ yr    │ r      │ s      │ t       │ value     │\n│     │ Int64 │ String │ String │ String  │ Float64   │\n├─────┼───────┼────────┼────────┼─────────┼───────────┤\n│ 1   │ 2015  │ md     │ agr    │ exports │ 0.0390152 │\n│ 2   │ 2015  │ md     │ agr    │ imports │ 0.778159  │\n│ 3   │ 2015  │ va     │ agr    │ exports │ 1.11601   │\n│ 4   │ 2015  │ va     │ agr    │ imports │ 0.88253   │\n│ 5   │ 2016  │ md     │ agr    │ exports │ 0.0330508 │\n│ 6   │ 2016  │ md     │ agr    │ imports │ 0.762089  │\n│ 7   │ 2016  │ va     │ agr    │ exports │ 1.16253   │\n│ 8   │ 2016  │ va     │ agr    │ imports │ 0.86741   │\n\njulia> extrapolate_region(df)\n12×5 DataFrame\n│ Row │ r      │ yr    │ s      │ t       │ value     │\n│     │ String │ Int64 │ String │ String  │ Float64   │\n├─────┼────────┼───────┼────────┼─────────┼───────────┤\n│ 1   │ dc     │ 2015  │ agr    │ exports │ 0.0390152 │\n│ 2   │ dc     │ 2015  │ agr    │ imports │ 0.778159  │\n│ 3   │ dc     │ 2016  │ agr    │ exports │ 0.0330508 │\n│ 4   │ dc     │ 2016  │ agr    │ imports │ 0.762089  │\n│ 5   │ md     │ 2015  │ agr    │ exports │ 0.0390152 │\n│ 6   │ md     │ 2015  │ agr    │ imports │ 0.778159  │\n│ 7   │ md     │ 2016  │ agr    │ exports │ 0.0330508 │\n│ 8   │ md     │ 2016  │ agr    │ imports │ 0.762089  │\n│ 9   │ va     │ 2015  │ agr    │ exports │ 1.11601   │\n│ 10  │ va     │ 2015  │ agr    │ imports │ 0.88253   │\n│ 11  │ va     │ 2016  │ agr    │ exports │ 1.16253   │\n│ 12  │ va     │ 2016  │ agr    │ imports │ 0.86741   │\n\nIf we instead want to copy VA data into DC, specify:\n\njulia> extrapolate_region(df, \"va\" => \"dc\")\n12×5 DataFrame\n│ Row │ r      │ yr    │ s      │ t       │ value     │\n│     │ String │ Int64 │ String │ String  │ Float64   │\n├─────┼────────┼───────┼────────┼─────────┼───────────┤\n│ 1   │ dc     │ 2015  │ agr    │ exports │ 1.11601   │\n│ 2   │ dc     │ 2015  │ agr    │ imports │ 0.88253   │\n│ 3   │ dc     │ 2016  │ agr    │ exports │ 1.16253   │\n│ 4   │ dc     │ 2016  │ agr    │ imports │ 0.86741   │\n│ 5   │ md     │ 2015  │ agr    │ exports │ 0.0390152 │\n│ 6   │ md     │ 2015  │ agr    │ imports │ 0.778159  │\n│ 7   │ md     │ 2016  │ agr    │ exports │ 0.0330508 │\n│ 8   │ md     │ 2016  │ agr    │ imports │ 0.762089  │\n│ 9   │ va     │ 2015  │ agr    │ exports │ 1.11601   │\n│ 10  │ va     │ 2015  │ agr    │ imports │ 0.88253   │\n│ 11  │ va     │ 2016  │ agr    │ exports │ 1.16253   │\n│ 12  │ va     │ 2016  │ agr    │ imports │ 0.86741   │\n\n\n\n\n\n","category":"function"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"map_year","category":"page"},{"location":"api/functions/filter.html#SLiDE.map_year","page":"Filter and Resize","title":"SLiDE.map_year","text":"This function returns a DataFrame defining mapping for a step function.\n\nKeywords\n\nfun::Function: how to pick the cut-off boundary. By default, this is set to occur   between to values. For example, this would result in using 2007 data for years <= 2009   and 2012 data for years >= 2009.\n\nReturns\n\nExample\n\njulia> map_year([2007,2012] => 2005:2015)\n11×2 DataFrame\n│ Row │ from  │ to    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 2007  │ 2005  │\n│ 2   │ 2007  │ 2006  │\n│ 3   │ 2007  │ 2007  │\n│ 4   │ 2007  │ 2008  │\n│ 5   │ 2007  │ 2009  │\n│ 6   │ 2012  │ 2010  │\n│ 7   │ 2012  │ 2011  │\n│ 8   │ 2012  │ 2012  │\n│ 9   │ 2012  │ 2013  │\n│ 10  │ 2012  │ 2014  │\n│ 11  │ 2012  │ 2015  │\n\n\n\n\n\n","category":"function"},{"location":"api/functions/filter.html#Fill","page":"Filter and Resize","title":"Fill","text":"","category":"section"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"fill_zero","category":"page"},{"location":"api/functions/filter.html#SLiDE.fill_zero","page":"Filter and Resize","title":"SLiDE.fill_zero","text":"fill_zero(keys_unique::NamedTuple; value_colnames)\nfill_zero(keys_unique::NamedTuple, df::DataFrame)\nfill_zero(df::DataFrame...)\nfill_zero(d::Dict...)\nfill_zero(keys_unique, d::Dict)\n\nThis function can be used to fill zeros in either a dictionary or DataFrame.\n\nOptions for dictionary editing:\nIf only (a) dictionary/ies is/are input, the dictionaries will be edited such that   they all contain all permutations of their key values. All dictionaries in a   resultant list of dictionaries will be the same length.\nIf a dictionary is input with a list of keys, it will be edited to ensure that it   includes all permutations.\nIf only a list of keys is input, a new dictionary will be created, containing all key   permutations with values initialized to zero.\nOptions for DataFrame editing:\nIf only (a) DataFrame(s) is/are input, the DataFrame(s) will be edited such that   they all contain all permutations of their key values. All DataFrames in a   resultant list of DataFrames will be the same length.\nIf a DataFrame is input with a NamedTuple, it will be edited to ensure that it   includes all permutations of the NamedTuple's values.\nIf only a NamedTuple is input, a new DataFrame will be created, containing all key   permutations with values initialized to zero.\n\nArguments\n\nkeys_unique::Tuple: A list of arrays whose permutations should be included in the   resultant dictionary.\nkeys_unique::NamedTuple: A list of arrays whose permutations should be included in the   resultant dictionary. The NamedTuple's keys correspond to the DataFrame columns where   they will be stored.\nd::Dict...: The dictionary/ies to edit.\ndf::DataFrame...: The DataFrame(s) to edit.\n\nKeywords\n\nvalue_colnames::Any = :value: \"value\" column labels to add and set to zero when creating   a new DataFrame. Default is :value.\n\nReturns\n\nd::Dict... if input included dictionaries and/or Tuples\ndf::DataFrame... if input included DataFrames and/or NamedTuples\n\n\n\n\n\n","category":"function"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"Initialize a new DataFrame or dictionary.","category":"page"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"using SLiDE","category":"page"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"years = 2015:2016; regions = [\"md\",\"va\"];\nfill_zero((years, regions))\nfill_zero((yr = years, r = regions))","category":"page"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"Edit an existing DataFrame or dictionary.","category":"page"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"df = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"data\",\"fill_use.csv\"))\nfill_zero(df)","category":"page"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"d = convert_type(Dict, df)\nfill_zero(d)","category":"page"},{"location":"api/functions/filter.html","page":"Filter and Resize","title":"Filter and Resize","text":"fill_with","category":"page"},{"location":"api/functions/filter.html#SLiDE.fill_with","page":"Filter and Resize","title":"SLiDE.fill_with","text":"Initialize a new DataFrame and fills it with the specified input value.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/build.html#Build","page":"Build","title":"Build","text":"","category":"section"},{"location":"api/internals/build.html","page":"Build","title":"Build","text":"Modules = [SLiDE]\nPages = [\"build/build.jl\"]\nPublic = false","category":"page"},{"location":"api/internals/build.html#SLiDE.build_eem-Tuple{Dataset,Dict,Dict}","page":"Build","title":"SLiDE.build_eem","text":"build_eem(dataset::Dataset)\n\nIf dataset.eem=true, continue the SLiDE buildstream for the Energy-Environment Module. If the dataset has already been generated and saved, the function will read and return those values.\n\nOtherwise, it will execute the build routine via the following functions:\n\nSLiDE.scale_sector\nSLiDE.partition_seds\nSLiDE.disaggregate_energy!\nSLiDE.partition_co2!\nSLiDE.calibrate_regional\n\nArguments\n\ndataset::Dataset identifier\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.build_io-Tuple{Dataset}","page":"Build","title":"SLiDE.build_io","text":"build_io(dataset::Dataset)\n\nIf the dataset has already been generated and saved, the function will read and return those values.\n\nOtherwise, it will read input data from the /SLIDE_DIR/data/input/ directory and execute the four steps of the SLiDE buildstream via the following functions:\n\nSLiDE.partition_bea\nSLiDE.calibrate_national\nSLiDE.share_region\nSLiDE.disaggregate_region\n\nArguments\n\ndataset::Dataset identifier\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.data_saved-Tuple{Dataset}","page":"Build","title":"SLiDE.data_saved","text":"This function returns true if parameters and sets have already been generated, and their values saved, for the given dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.datapath-Tuple{Dataset}","page":"Build","title":"SLiDE.datapath","text":"datapath(dataset::Dataset)\n\nThis function returns the path to the directory location specified by dataset.name/dataset.build/dataset.step. Building a dataset called dataset.name with dataset.save_build=true will produce files in the following structure.     /SLIDE_DATA/data/dataset.name/     ├── eem/     |   ├── parameters/     |   └── sets/     ├── io/     |   ├── parameters/     └───└── sets/\n\nArguments\n\ndataset::String: Dataset identifier\n\nReturns\n\ndir::String = /path/to/dataset\nSLIDE_DIR is the path to the location of the SLiDE.jl package on the user's machine.\nThe default dataset identifier is state_model. This dataset includes all   U.S. states and summary-level sectors and goods.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.describe-Tuple{Dataset}","page":"Build","title":"SLiDE.describe","text":"describe!(set::Dict, dataset::Dataset)\ndescribe(dataset::Dataset)\n\nArguments\n\ndataset::Dataset or step::String/Symbol specifying the parameters to describe\n\nReturns\n\nd::Dict{Symbol,Parameter} of Parameters relevant to the specified data   step. The dictionary key is consistent the value's field parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.list-Tuple{Dataset}","page":"Build","title":"SLiDE.list","text":"list!(set::Dict, dataset::Dataset)\n\nThis function adds a list of the parameters described by SLiDE.describe to set, identified by the key :step_list.\n\nArguments\n\nset::Dict to update\ndataset::Dataset or step::Symbol\n\nReturns\n\nlst::AbstractArray of parameters added to set\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.overwrite-Tuple{Dataset}","page":"Build","title":"SLiDE.overwrite","text":"overwrite(dataset::Dataset)\n\nThis function executes dataset.overwrite=true. If a directory exists at dataset.name/dataset.build, and\n\nOutput data HAS been generated, append the date this directory was created and move it.\nOutput data HAS NOT yet been generated, remove the directory and start over.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.read_build-Tuple{Dataset}","page":"Build","title":"SLiDE.read_build","text":"read_build(dataset::Dataset)\n\nThis function reads data from or for the specified dataset if this information has previously been generated and saved, read the saved data. If this information has NOT yet been generated, read input data using SLiDE.read_input!.\n\nArguments\n\ndataset::Dataset identifier\nsubset::String: Internally-passed parameter indicating the type of information to save   (set, parameter, or build step)\n\nReturns\n\nd::Dict{Symbol,DataFrame} if reading parameters or d::Dict{Any,Array} if reading sets\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.read_input!-Tuple{Dataset}","page":"Build","title":"SLiDE.read_input!","text":"read_input!(dataset::Dataset)\n\nRead input data for the specified dataset.build/dataset.step and set dataset.step=\"input to indicate further action is required.\n\nArguments\n\ndataset::Dataset identifier\n\nReturns\n\nd::Dict of input data. If dataset.step does not require input data, return Dict().\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.read_map-Tuple{}","page":"Build","title":"SLiDE.read_map","text":"read_map()\n\nReturns\n\nd::Dict of EEM mapping datasets.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.read_set-Tuple{String}","page":"Build","title":"SLiDE.read_set","text":"read_set()\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.set_sector!-Tuple{Dict,AbstractArray}","page":"Build","title":"SLiDE.set_sector!","text":"\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.write_build!-Tuple{Dataset,Dict}","page":"Build","title":"SLiDE.write_build!","text":"write_build!(dataset::Dataset, d::Dict)\n\nThis function filters the contents of the input dictionary d to include only relevant files using SLiDE.filter_with! and writes set lists and parameter DataFrames to csv files in the directory named by SLiDE.datapath and named for their associated dictionary key.\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of information to write\n\nReturns\n\nd::Dict: filtered dictionary\n\n\n\n\n\n","category":"method"},{"location":"api/internals/build.html#SLiDE.write_build-Tuple{Any,Any,DataFrames.DataFrame}","page":"Build","title":"SLiDE.write_build","text":"write_build(path::String, k::Symbol, df::DataFrame)\nwrite_build(path::String, k::Symbol, lst::AbstractArray)\n\nThis is a helper function for SLiDE.write_build!.\n\nArguments\n\npath::String = /path/to/dataset\nk: filename\ndf::DataFrame or lst::AbstractArray of data to write\n\n\n\n\n\n","category":"method"},{"location":"api/functions/model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api/functions/model.html#Index","page":"Model","title":"Index","text":"","category":"section"},{"location":"api/functions/model.html","page":"Model","title":"Model","text":"Pages = [\"model.md\"]","category":"page"},{"location":"api/functions/model.html#Functions","page":"Model","title":"Functions","text":"","category":"section"},{"location":"api/functions/model.html","page":"Model","title":"Model","text":"These functions were developed to set and update JuMP.Model variables.","category":"page"},{"location":"api/functions/model.html","page":"Model","title":"Model","text":"SLiDE.set_lower_bound!\nSLiDE.lower_bound\nSLiDE.set_upper_bound!\nSLiDE.upper_bound\nSLiDE.set_bounds!\nSLiDE.fix!\nSLiDE.fix_lower_bound!","category":"page"},{"location":"api/functions/model.html#SLiDE.set_lower_bound!","page":"Model","title":"SLiDE.set_lower_bound!","text":"set_lower_bound!(model::JuMP.Model, var, idx; kwargs...)\n\nThis function sets a JuMP Model variable's lower bound as calculated by SLiDE.lower_bound.\n\nArguments\n\nmodel::JuMP.Model to update\nvar::Symbol or var::AbstractArray: variable or list of variables to update\nidx::Symbol, idx::Tuple, or idx::AbstractArray: index or list of indices overwhich   to set bounds.\n\nKeyword Arguments\n\nConsistent with SLiDE.lower_bound\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html#SLiDE.lower_bound","page":"Model","title":"SLiDE.lower_bound","text":"lower_bound(x::Real; kwargs...)\n\nThis function calculates a lower bound on x:     ```math     x{lower} =     \\begin{cases}     \\max\\left{0,\\, factor \\cdot x \\right}  & \\texttt{allownegative}     \n    factor \\cdot x                                 & \\texttt{!allow_negative}     \\end{cases}     ```\n\nArguments\n\nx::Real reference value to calculate lower bound\n\nKeyword Arguments\n\nfactor::Real=0 to use to calculate lower bound.\nvalue::Real=NaN: If a value is given, set lower bound to this value.\nallow_negative::Bool=true: Do we want to set negative values to zero?\n\nReturns\n\nx::Real: calculted lower bound\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html#SLiDE.set_upper_bound!","page":"Model","title":"SLiDE.set_upper_bound!","text":"set_upper_bound!(model::JuMP.Model, var, idx; kwargs...)\n\nThis function sets a JuMP Model variable's upper bound as calculated by SLiDE.upper_bound.\n\nArguments\n\nmodel::JuMP.Model to update\nvar::Symbol or var::AbstractArray: variable or list of variables to update\nidx::Symbol, idx::Tuple, or idx::AbstractArray: index or list of indices overwhich   to set bounds.\n\nKeyword Arguments\n\nConsistent with SLiDE.upper_bound\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html#SLiDE.upper_bound","page":"Model","title":"SLiDE.upper_bound","text":"upper_bound(x::Real; kwargs...)\n\nThis function returns an upper bound on x:     ```math     x{upper} =     \\begin{cases}     \\abs\\left{factor \\cdot x \\right}  & \\texttt{allownegative}     \n    factor \\cdot x                           & \\texttt{!allow_negative}     \\end{cases}     ```\n\nArguments\n\nx::Real reference value to calculate upper bound\n\nKeyword Arguments\n\nfactor::Real=0 to use to calculate upper bound.\nvalue::Real=NaN: If a value is given, set upper bound to this value.\nallow_negative::Bool=true: Do we want to make negative values positive?\n\nReturns\n\nx::Real: calculted upper bound\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html#SLiDE.set_bounds!","page":"Model","title":"SLiDE.set_bounds!","text":"set_bounds!(model::JuMP.Model, var, idx; kwargs...)\n\nThis function sets upper and lower bound on the specified JuMP Model variable(s).\n\nArguments\n\nmodel::JuMP.Model to update\nvar::Symbol or var::AbstractArray: variable or list of variables to update\nidx::Symbol, idx::Tuple, or idx::AbstractArray: index or list of indices overwhich   to set bounds.\n\nKeyword Arguments\n\nlower_factor::Real=0: passed to SLiDE.lower_bound as factor\nupper_factor::Real=0: passed to SLiDE.upper_bound as factor\nallow_negative::Bool=true: passed to SLiDE.lower_bound and SLiDE.upper_bound\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html#SLiDE.fix!","page":"Model","title":"SLiDE.fix!","text":"fix!(model::JuMP.Model, var, idx; kwargs...)\n\nThis function fixes a model variable model[var][idx] if its start value meets a specified condition.\n\nArguments\n\nmodel::JuMP.Model to update\nvar::Symbol or var::AbstractArray: variable or list of variables to update\nidx::Symbol, idx::Tuple, or idx::AbstractArray: index or list of indices overwhich   to set bounds.\n\nKeyword Arguments\n\nvalues::Real=NaN, to which to fix the JuMP Variable if it meets the condition.   If value==NaN, as is specified by default, fix the variable based on its start value.\ncondition::Function=isreal, that determines whether to fix the value. By default, all   Real-valued start values will be fixed. If, for instance, condition=iszero, is given,   all variables with start values of zero will be fixed to zero.   Non-zero values will not be fixed.\nforce::true, passed to JuMP.fix\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html#SLiDE.fix_lower_bound!","page":"Model","title":"SLiDE.fix_lower_bound!","text":"fix_lower_bound!(model::JuMP.Model, var, idx; kwargs...)\n\nThis function fixes a model variable model[var][idx] if its start value meets a specified condition using SLiDE.fix!, OR sets its lower bound using SLiDE.set_lower_bound!.\n\nArguments\n\nmodel::JuMP.Model to update\nvar::Symbol or var::AbstractArray: variable or list of variables to update\nidx::Symbol, idx::Tuple, or idx::AbstractArray: index or list of indices overwhich   to set bounds.\n\nKeyword Arguments\n\nSee [SLiDE.fix!] and [SLiDE.lower_bound]\n\n\n\n\n\n","category":"function"},{"location":"api/functions/model.html","page":"Model","title":"Model","text":"SLiDE.zero_negative!","category":"page"},{"location":"api/functions/model.html#SLiDE.zero_negative!","page":"Model","title":"SLiDE.zero_negative!","text":"This function sets negative values to zero.\n\nArguments\n\nzero_negative!(d)\nzero_negative!(d, var)\n\nd::Dict{Symbol,DataFrame} to edit\nvar::Symbol or var::AbstractArray: variable or list of variables to edit\nzeronegative!(df)   zeronegative!(df, subset)\ndf::DataFrame to edit\nsubset::Pair: If given, only zero negative values for this idx => value pair.\n\nReturns\n\ndf::DataFrame or d::Dict{Symbol,DataFrame} with negative values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/calc.html#Calculations","page":"Calculations","title":"Calculations","text":"","category":"section"},{"location":"api/functions/calc.html","page":"Calculations","title":"Calculations","text":"SLiDE.impute_mean","category":"page"},{"location":"api/functions/calc.html#SLiDE.impute_mean","page":"Calculations","title":"SLiDE.impute_mean","text":"impute_mean(df::DataFrame, col::Symbol)\n\nThis function fills missing values in df with the average over the index given in col using the standard mean. For a parameter z imputed over an index x, the average barz would be calculated:\n\nbarz = dfracsum_x zN\n\nIf a weight w is given, the weighted average would be calculated:\n\nbarz = dfracsum_x z cdot wsum_x w\n\nThis process of filling missing values is called \"mean imputation\".\n\nArguments\n\ndf::DataFrame with missing values\ncol::Symbol over which to average.\n\nKeyword Arguments\n\nweight::DataFrame=DataFrame() to use  when weighting.\ncondition::DataFrame=DataFrame() on which indices to keep in the output df_avg.   If no condition is given, all NaN values in the input df will be replaced.\n\nReturns\n\ndf_avg::DataFrame of mean.\ndf::DataFrame of unchanged values\n\n\n\n\n\n","category":"function"},{"location":"api/functions/calc.html","page":"Calculations","title":"Calculations","text":"SLiDE.indexjoin\nSLiDE.combine_over\nSLiDE.transform_over","category":"page"},{"location":"api/functions/calc.html#SLiDE.indexjoin","page":"Calculations","title":"SLiDE.indexjoin","text":"indexjoin(df::DataFrame...; kwargs)\nindexjoin(df::Array{DataFrame,1}; kwargs)\n\nThis function joins input DataFrames on their index columns (ones that are not filled with  AbstractFloat or Bool DataTypes)\n\nArgument\n\ndf::DataFrame... to join.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/calc.html#SLiDE.combine_over","page":"Calculations","title":"SLiDE.combine_over","text":"combine_over(df::DataFrame, col::Array{Symbol,1}; operation::Function = sum)\ncombine_over(df::DataFrame, col::Symbol; operation::Function = sum)\n\nThis function applies combine to the input DataFrame df over the input column(s) col.\n\nArguments\n\ndf::DataFrame: DataFrame on which to operate.\ncol::Symbol or col::Array{Symbol,1}: column(s) over which to operate.\n\nKeywords\n\noperation::Function = sum: Operation to perform over the DataFrame columns. By default,   the function will return a summation. Other standard summary functions include: sum,   prod, minimum, maximum, mean, var, std, first, last and length.\n\nReturns\n\ndf::DataFrame WITHOUT the specified column(s) argument. The resulting DataFrame will be   'shorter' than the input DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/calc.html#SLiDE.transform_over","page":"Calculations","title":"SLiDE.transform_over","text":"transform_over(df::DataFrame, col::Array{Symbol,1}; operation::Function = sum)\ntransform_over(df::DataFrame, col::Symbol; operation::Function = sum)\n\nThis function applies transform to the input DataFrame df over the input column(s) col.\n\nArguments\n\ndf::DataFrame: DataFrame on which to operate.\ncol::Symbol or col::Array{Symbol,1}: column(s) over which to operate.\n\nKeywords\n\noperation::Function = sum: Operation to perform over the DataFrame columns. By default,   the function will return a summation. Other standard summary functions include: sum,   prod, minimum, maximum, mean, var, std, first, last and length.\n\nReturns\n\ndf::DataFrame WITH the specified column(s) argument. The resulting DataFrame will be   the same length as the input DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/calc.html","page":"Calculations","title":"Calculations","text":"SLiDE.operate_over","category":"page"},{"location":"api/functions/calc.html#SLiDE.operate_over","page":"Calculations","title":"SLiDE.operate_over","text":"\n\n\n\n","category":"function"},{"location":"api/types/parse.html#Parsing","page":"Parsing","title":"Parsing","text":"","category":"section"},{"location":"api/types/parse.html#Edit","page":"Parsing","title":"Edit","text":"","category":"section"},{"location":"api/types/parse.html","page":"Parsing","title":"Parsing","text":"Modules = [SLiDE]\nPrivate = false\nFilter = t -> t <: SLiDE.Edit\nOrder = [:type]","category":"page"},{"location":"api/types/parse.html#SLiDE.Add","page":"Parsing","title":"SLiDE.Add","text":"mutable struct Add <: Edit\n    col::Symbol\n    val::Any\nend\n\nAdd new column col filled with val\n\nArguments\n\ncol::Symbol: name of new column\nval::Any: value to add to new column\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Combine","page":"Parsing","title":"SLiDE.Combine","text":"mutable struct Combine <: Edit\n    operation::String\n    output::Array{Symbol,1}\nend\n\nArguments\n\noperation::String: operation to perform (+, -, *, /)\noutput::Array{Symbol,1}\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Concatenate","page":"Parsing","title":"SLiDE.Concatenate","text":"mutable struct Concatenate <: Edit\n    col::Array{Symbol,1}\n    on::Array{Symbol,1}\n    var::Symbol\nend\n\nConcatenate side-by-side DataFrames into one normal-form DataFrame.\n\nArguments\n\ncol::Array{Symbol,1}: final column names\non::Array{Symbol,1}: column name indicator specifying where to stack\nvar::Symbol: column name for storing indicator\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Describe","page":"Parsing","title":"SLiDE.Describe","text":"mutable struct Describe <: Edit\n    col::Symbol\nend\n\nThis DataType is required when multiple DataFrames will be appended into one output file (say, if multiple sheets from an XLSX file are included). Before the DataFrames are appended, a column col will be added and filled with the value in the file descriptor. !!!! Does it make sense to have a DataType with one field?\n\nArguments\n\ncol::Symbol: name of new column\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Deselect","page":"Parsing","title":"SLiDE.Deselect","text":"mutable struct Deselect <: Edit\n    col::Array{Symbol,1}\n    operation::String\nend\n\nArguments\n\ncol::Array{Symbol,1}: name of column containing data to remove\noperation::String: how to determine what to drop\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Drop","page":"Parsing","title":"SLiDE.Drop","text":"mutable struct Drop <: Edit\n    col::Symbol\n    val::Any\n    operation::String\nend\n\nRemove information from the dataframe - either an entire column or rows containing specified values.\n\nArguments\n\ncol::Symbol: name of column containing data to remove\nval::Any: value to drop\noperation::String: how to determine what to drop\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Group","page":"Parsing","title":"SLiDE.Group","text":"mutable struct Group <: Edit\n    file::String\n    from::Symbol\n    to::Array{Symbol,1}\n    input::Symbol\n    output::Array{Symbol,1}\nend\n\nUse to edit files containing data in successive dataframes with an identifying header cell or row.\n\nArguments\n\nfile::String: mapping .csv file name in the coremaps directory. The mapping file should correlate with the header information identifying each data group. It will be used to separate the header rows from data.\nfrom::Symbol: name of the mapping column containing input values\nto::Array{Symbol,1}: name of the mapping column containing output values\ninput::Symbol: name of the input column containing\noutput::Array{Symbol,1}: name of the output column created\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Map","page":"Parsing","title":"SLiDE.Map","text":"mutable struct Map <: Edit\n    file::Any\n    from::Array{Symbol,1}\n    to::Array{Symbol,1}\n    input::Array{Symbol,1}\n    output::Array{Symbol,1}\n    kind::Symbol\nend\n\nDefine an output column containing values based on those in an input column. The mapping columns from -> to are contained in a .csv file in the coremaps directory. The columns input and from should contain the same values, as should output and to.\n\nArguments\n\nfile::Any: mapping .csv file name in the coremaps directory\nfrom::Array{Symbol,1}: name of the mapping column containing input values\nto::Array{Symbol,1}: name of the mapping column containing output values\ninput::Array{Symbol,1}: name of the input column to map\noutput::Array{Symbol,1}: name of the output column created\nkind::Symbol: type of join to perform.\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Match","page":"Parsing","title":"SLiDE.Match","text":"mutable struct Match <: Edit\n    on::Regex\n    input::Symbol\n    output::Array{Symbol,1}\nend\n\nExtract values from the specified column into a column or columns based on the specified regular expression.\n\nArguments\n\non::Regex: string indicating where to split\ninput::Symbol: column to split\noutput::Array{Symbol,1}: column names to label text surrounding the split\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Melt","page":"Parsing","title":"SLiDE.Melt","text":"mutable struct Melt <: Edit\n    on::Array{Symbol,1}\n    var::Symbol\n    val::Symbol\nend\n\nNormalize the dataframe by 'melting' columns into rows, lengthening the dataframe by duplicating values in the column on into new rows and defining 2 new columns: 1. var with header names from the original dataframe. 2. val with column values from the original dataframe. This operation can only be performed once per dataframe.\n\nArguments\n\non::Array{Symbol,1}: name of column(s) NOT included in melt\nvar::Symbol: name of column containing header NAMES from the original dataframe\nval::Symbol: name of column containing VALUES from the original dataframe\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Operate","page":"Parsing","title":"SLiDE.Operate","text":"mutable struct Operate <: Edit\n    operation::String\n    from::Array{Symbol,1}\n    to::Array{Symbol,1}\n    input::Array{Symbol,1}\n    output::Symbol\nend\n\nPerform an arithmetic operation across multiple DataFrame columns.\n\nArguments\n\noperation::String: operation to perform (+, -, *, /)\nfrom::Array{Symbol,1}: name of original comment column (ex. units)\nto::Array{Symbol,1}: name of new comment column (ex. units)\ninput::Array{Symbol,1}: names of columns on which to operate\noutput::Symbol: name of result column\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Order","page":"Parsing","title":"SLiDE.Order","text":"mutable struct Order <: Edit\n    col::Array{Symbol,1}\n    type::Array{DataType,1}\nend\n\nRearranges columns in the order specified by cols and sets them to the specified type.\n\nArguments\n\ncol::Array{Symbol,1}: Ordered list of DataFrame columns\ntype::Array{DataType,1}: Ordered column types.\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.OrderedGroup","page":"Parsing","title":"SLiDE.OrderedGroup","text":"mutable struct OrderedGroup <: Edit\n    on::Array{Symbol,1}\n    var::Symbol\n    val::Array{Any,1}\nend\n\nmaybe, if on and var are the same, we can just fill in groups? i'm thinking SCTG group.\n\nArguments\n\non::Array{Symbol,1}: name of columns containing information specific to a particular level\nvar::Symbol: name of column containing information of what we will unstack on\nval::Array{Any,1}: ordered list of values to unstack on. If empty, unstack in order of appearance.\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Rename","page":"Parsing","title":"SLiDE.Rename","text":"mutable struct Rename <: Edit\n    from::Symbol\n    to::Symbol\nend\n\nChange column name from -> to.\n\nArguments\n\nfrom::Symbol: original column name\nto::Symbol: new column name\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Replace","page":"Parsing","title":"SLiDE.Replace","text":"mutable struct Replace <: Edit\n    col::Symbol\n    from::Any\n    to::Any\nend\n\nReplace values in col from -> to.\n\nArguments\n\ncol::Symbol: name of column containing values to be replaced\nfrom::Any: value to replace\nto::Any: new value\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.Stack","page":"Parsing","title":"SLiDE.Stack","text":"mutable struct Stack <: Edit\n    on::Array{Symbol,1}\n    var::Symbol\n    val::Symbol\nend\n\nNormalize the dataframe by 'melting' columns into rows, lengthening the dataframe by duplicating values in the column on into new rows and defining 2 new columns: 1. var with header names from the original dataframe. 2. val with column values from the original dataframe. This operation can only be performed once per dataframe.\n\nArguments\n\non::Array{Symbol,1}: name of column(s) NOT included in melt\nvar::Symbol: name of column containing header NAMES from the original dataframe\nval::Symbol: name of column containing VALUES from the original dataframe\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#File","page":"Parsing","title":"File","text":"","category":"section"},{"location":"api/types/parse.html","page":"Parsing","title":"Parsing","text":"Modules = [SLiDE]\nPrivate = false\nFilter = t -> t <: SLiDE.File\nOrder = [:type]","category":"page"},{"location":"api/types/parse.html#SLiDE.CSVInput","page":"Parsing","title":"SLiDE.CSVInput","text":"mutable struct CSVInput <: File\n    name::String\n    descriptor::String\nend\n\nRead .csv file\n\nArguments\n\nname::String: input file name\ndescriptor::String: file descriptor\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.DataInput","page":"Parsing","title":"SLiDE.DataInput","text":"mutable struct DataInput <: File\n    name::String\n    descriptor::String\n    col::Array{Symbol,1}\nend\n\nRead .csv file with specific column names\n\nArguments\n\nname::String: input file name\ndescriptor::String: file descriptor\ncol::Array{Symbol,1}: data column names\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.GAMSInput","page":"Parsing","title":"SLiDE.GAMSInput","text":"mutable struct GAMSInput <: File\n    name::String\n    col::Array{Symbol,1}\nend\n\nRead .map or .set file\n\nArguments\n\nname::String: input file name\ncol::Array{Symbol,1}: column names\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.SetInput","page":"Parsing","title":"SLiDE.SetInput","text":"mutable struct SetInput <: File\n    name::String\n    descriptor::Symbol\nend\n\nRead .csv file with specific column names\n\nArguments\n\nname::String: input file name\ndescriptor::Symbol: file descriptor\n\n\n\n\n\n","category":"type"},{"location":"api/types/parse.html#SLiDE.XLSXInput","page":"Parsing","title":"SLiDE.XLSXInput","text":"mutable struct XLSXInput <: File\n    name::String\n    sheet::String\n    range::String\n    descriptor::String\nend\n\nRead .xlsx file.\n\nArguments\n\nname::String: input file name\nsheet::String: input sheet name\nrange::String: input sheet range\ndescriptor::String: file descriptor\n\n\n\n\n\n","category":"type"},{"location":"man/build/io/disagg_region.html#Regional-Disaggregation","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"","category":"section"},{"location":"man/build/io/disagg_region.html","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"SLiDE.disaggregate_region","category":"page"},{"location":"man/build/io/disagg_region.html#SLiDE.disaggregate_region","page":"Regional Disaggregation","title":"SLiDE.disaggregate_region","text":"disaggregate_region(dataset::Dataset, d::Dict, set::Dict)\n\nThis function disaggregates national-level parameters to the regional level and introduces new parameters.\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\nReturns\n\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"SLiDE._disagg_ys0!\nSLiDE._disagg_id0!\nSLiDE._disagg_ty0!\nSLiDE._disagg_va0!\nSLiDE._disagg_ld0!\nSLiDE._disagg_kd0!","category":"page"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_ys0!","page":"Regional Disaggregation","title":"SLiDE._disagg_ys0!","text":"ys(yr,r,s,g), regional sectoral output\n\nbarys_yrrsg = alpha_yrrs^gsp tildeys_yrsg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_id0!","page":"Regional Disaggregation","title":"SLiDE._disagg_id0!","text":"id(yr,r,g,s), regional intermediate demand\n\nbarid_yrrgs = alpha_yrrs^gsp tildeid_yrgs\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_ty0!","page":"Regional Disaggregation","title":"SLiDE._disagg_ty0!","text":"ty(yr,r,s), production tax rate\n\nbeginaligned\nbarty_yrrs^rev = alpha_yrrs^gsp tildeva_yrvas forall va = othtax \nbarty_yrrs = fractildety_yrrssum_g barys_yrrsg\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_va0!","page":"Regional Disaggregation","title":"SLiDE._disagg_va0!","text":"va(yr,va,s), regional value added\n\nbarva_yrrs = alpha_yrrs^gsp sum_va = compensurplus tildeva_yrvas\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_ld0!","page":"Regional Disaggregation","title":"SLiDE._disagg_ld0!","text":"ld0(yr,r,s), labor demand\n\nbarld_yrrs = theta_yrrs^ls barva_yrsg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_kd0!","page":"Regional Disaggregation","title":"SLiDE._disagg_kd0!","text":"kd0(yr,r,s), capital demand\n\nbarkd_yrrs = barva_yrrs - barld_yrrs\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"SLiDE._disagg_fdcat!\nSLiDE._disagg_g0!\nSLiDE._disagg_i0!\nSLiDE._disagg_cd0!\nSLiDE._disagg_c0!","category":"page"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_fdcat!","page":"Regional Disaggregation","title":"SLiDE._disagg_fdcat!","text":"_disagg_fdcat!(d::Dict)\n\nThis function aggregates final demand categories into national consumption (C), government (G), and investment (I) demand.\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_g0!","page":"Regional Disaggregation","title":"SLiDE._disagg_g0!","text":"g0(yr,r,g), national government demand\n\nbarg_yrrg = alpha_yrrg^sgf sum_G in fd tildefd_yrgfd\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_i0!","page":"Regional Disaggregation","title":"SLiDE._disagg_i0!","text":"i0(yr,r,g), national investment demand\n\nbari_yrrg = alpha_yrrg^gsp sum_I in fd tildefd_yrgfd\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_cd0!","page":"Regional Disaggregation","title":"SLiDE._disagg_cd0!","text":"cd0(yr,r,g), national final consumption\n\nbarcd_yrrg = alpha_yrrg^pce sum_C in fd tildefd_yrgfd\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_c0!","page":"Regional Disaggregation","title":"SLiDE._disagg_c0!","text":"c0(yr,r), total final household consumption\n\nbarc_yrr = sum_g barcd_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"SLiDE._disagg_yh0!\nSLiDE._disagg_s0!\nSLiDE._disagg_x0!\nSLiDE._disagg_rx0!","category":"page"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_yh0!","page":"Regional Disaggregation","title":"SLiDE._disagg_yh0!","text":"yh0(yr,r,g), household production\n\nbaryh_yrrg = alpha_yrrg tildefs_yrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_s0!","page":"Regional Disaggregation","title":"SLiDE._disagg_s0!","text":"s0(yr,r,g), total supply\n\nbars_yrrg = sum_s barys_yrrsg + baryh_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_x0!","page":"Regional Disaggregation","title":"SLiDE._disagg_x0!","text":"x0(yr,r,g), foreign exports\n\nbarx_yrrg = alpha_yrrg^utd tildex_yrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_rx0!","page":"Regional Disaggregation","title":"SLiDE._disagg_rx0!","text":"rx0(yr,r,g), re-exports\n\nbarrx_yrrg = barx_yrrg - bars_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"SLiDE._disagg_a0!\nSLiDE._disagg_thetaa!\nSLiDE._disagg_m0!\nSLiDE._disagg_md0!\nSLiDE._disagg_bop!\n\nSLiDE._disagg_pt0\nSLiDE._disagg_dc0!\nSLiDE._disagg_dd0max!\nSLiDE._disagg_dd0!\nSLiDE._disagg_nd0!\n\nSLiDE._disagg_mrgshr\nSLiDE._disagg_ms0tot!\nSLiDE._disagg_shrtrd!\nSLiDE._disagg_dm0!\nSLiDE._disagg_nm0!\nSLiDE._disagg_xd0!\nSLiDE._disagg_xn0!\nSLiDE._disagg_hhadj!","category":"page"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_a0!","page":"Regional Disaggregation","title":"SLiDE._disagg_a0!","text":"a0(yr,r,g), domestic absorption\n\na_yrrg = barcd_yrrg + barg_yrrg + bari_yrrg + sum_sbarid_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_thetaa!","page":"Regional Disaggregation","title":"SLiDE._disagg_thetaa!","text":"thetaa(yr,r,g), share of regional absorption\n\nalpha_yrrg^abs = fracbara_yrrgsum_rrbara_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_m0!","page":"Regional Disaggregation","title":"SLiDE._disagg_m0!","text":"m0(yr,r,g), foreign imports\n\nbarm_yrrg = alpha_yrrg^abs tildem_yrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_md0!","page":"Regional Disaggregation","title":"SLiDE._disagg_md0!","text":"md0(yr,r,m,g), margin demand\n\nbarmd_yrrmg = alpha_yrrg^abs tildemd_yrmg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_bop!","page":"Regional Disaggregation","title":"SLiDE._disagg_bop!","text":"bopdef0(yr,r), balance of payments (closure parameter)\n\nbarbop_yrr = sum_g left( barm_yrrg - barx_yrrg right)\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_pt0","page":"Regional Disaggregation","title":"SLiDE._disagg_pt0","text":"pt0, \n\nbeginaligned\nbarpt_yrrg = left(1 - barta_yrrg right) bara_yrrg + barrx_yrrg\n               - left(1 + bartm_yrrg right) barm_yrrg - sum_m barmd_yrrmg\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_dc0!","page":"Regional Disaggregation","title":"SLiDE._disagg_dc0!","text":"dc0, \n\nbardc_yrrg = bars_yrrg - barx_yrrg + barrx_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_dd0max!","page":"Regional Disaggregation","title":"SLiDE._disagg_dd0max!","text":"dd0max(yr,r,g), maximum regional demand from local market\n\nhatdd_yrrg = minleftbarpt_yrrg bardc_yrrg right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_dd0!","page":"Regional Disaggregation","title":"SLiDE._disagg_dd0!","text":"dd0(yr,r,g), regional demand from local market\n\nbardd_yrrg = rho_rg^cfs hatdd_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_nd0!","page":"Regional Disaggregation","title":"SLiDE._disagg_nd0!","text":"nd0_(yr,r,g), regional demand from national market\n\nbarnd_yrrg = barpt_yrrg - bardd_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_mrgshr","page":"Regional Disaggregation","title":"SLiDE._disagg_mrgshr","text":"mrgshr(yr,r,m), share of margin demand by region\n\nalpha_yrrm^md = fracsum_gbarmd_yrrmgsum_rgbarmd_yrrmg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_ms0tot!","page":"Regional Disaggregation","title":"SLiDE._disagg_ms0tot!","text":"ms0tot(yr,r,m,g), designate total supply of margins\n\nhatms_yrrmg = alpha_yrrm^md barms_yrgm\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_shrtrd!","page":"Regional Disaggregation","title":"SLiDE._disagg_shrtrd!","text":"shrtrd(yr,r,g,m), share of margin total by margin type\n\nbeta_yrrgm^mar = frachatms_yrrgmsum_mhatms_yrrgm\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_dm0!","page":"Regional Disaggregation","title":"SLiDE._disagg_dm0!","text":"dm0(yr,r,g,m), margin supply from the local market\n\nbardm_yrrgm = minleft rho_rg^cfshatms_yrrgm\n    beta_yrrmg^mar left(bardc_yrrg - bardd_yrrgright) right\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_nm0!","page":"Regional Disaggregation","title":"SLiDE._disagg_nm0!","text":"nm0(yr,r,g,m), margin demand from the national market\n\nbarnm_yrrgm = hatms_yrrgm - bardm_yrrgm\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_xd0!","page":"Regional Disaggregation","title":"SLiDE._disagg_xd0!","text":"xd0(yr,r,g), regional supply to local market\n\nbarxd_yrrg = sum_mbardm_yrrgm + bardd_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_xn0!","page":"Regional Disaggregation","title":"SLiDE._disagg_xn0!","text":"xn0(yr,r,g), regional supply to national market\n\nbarxn_yrrg = bars_yrrg + barrx_yrrg - barxd_yrrg - barx_yrrg\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_hhadj!","page":"Regional Disaggregation","title":"SLiDE._disagg_hhadj!","text":"hhadj(yr,r), household adjustment\n\nbeginaligned\nbaradj^hh_yrr = barc_yrr\n - sum_sleft( barld_yrrs + barkd_yrrs + baryh_yrrs right) - barbop_yrr\n - sum_sleft( barta_yrrsbara0_yrrs + bartm_yrrsbarm_yrrs + barty_yrrssum_gbarys_yrrsg right)\n + sum_sleft( barg_yrrs + bari_yrrs right)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html","page":"Regional Disaggregation","title":"Regional Disaggregation","text":"SLiDE._disagg_ta0!\nSLiDE._disagg_tm0!","category":"page"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_ta0!","page":"Regional Disaggregation","title":"SLiDE._disagg_ta0!","text":"ta0(yr,r,g): Absorption taxes\n\n\n\n\n\n","category":"function"},{"location":"man/build/io/disagg_region.html#SLiDE._disagg_tm0!","page":"Regional Disaggregation","title":"SLiDE._disagg_tm0!","text":"tm0(yr,r,g): Import taxes\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#Parameters","page":"Energy Disaggregation","title":"Parameters","text":"","category":"section"},{"location":"man/build/eem/disagg_energy.html","page":"Energy Disaggregation","title":"Energy Disaggregation","text":"SLiDE.disaggregate_energy!","category":"page"},{"location":"man/build/eem/disagg_energy.html#SLiDE.disaggregate_energy!","page":"Energy Disaggregation","title":"SLiDE.disaggregate_energy!","text":"This function disaggregates national-level model parameters to the regional level and introduces new parameters.\n\nArguments\n\ndataset::Dataset identifier\nd::Dict of model parameters\nset::Dict of Arrays describing parameter indices (years, regions, goods, sectors, etc.)\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html","page":"Energy Disaggregation","title":"Energy Disaggregation","text":"SLiDE._disagg_energy_fvs!\nSLiDE._disagg_energy_md0!\nSLiDE._disagg_energy_mrgshr!\nSLiDE._disagg_energy_cd0!\nSLiDE._disagg_energy_ys0!\nSLiDE._disagg_energy_id0!\nSLiDE._disagg_energy_inpshr!\nSLiDE._disagg_energy_m0!\nSLiDE._disagg_energy_x0!\nSLiDE._disagg_energy_zero_prod!\nSLiDE._disagg_energy_zero_island!","category":"page"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_fvs!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_fvs!","text":"fvs, initial factor value shares in production\n\nfvs_yrrsx = dfracx_yrrssum_gys_yrrsg\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_md0!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_md0!","text":"md0(yr,r,m,g=e), margin demand\n\nmd_yrrmg = mrgshr_yrrmg cdot sum_sec emrg_yrrsrcrightarrow g sec\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_mrgshr!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_mrgshr!","text":"beginaligned\nmrgshr_yrrmg=trn = dfrac\n    md_yrrmg=trn\n    sum_m md_yrrmg=trn\n\nmrgshr_yrrmg=trd = 1 - mrgshr_yrrmg=trn\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_cd0!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_cd0!","text":"cd0(yr,r,g=e), national final consumption\n\nbarcd_yrrg\n= left\n    ed left(yrrsrcrightarrow g secright) vert yr r g sec=res\nright\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_ys0!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_ys0!","text":"For eneq oil,\n\nq_yrrsrc = left\n    energy(yrrsrcsec) vert sec=supply\nright\n\nv_yrrsrc=e text billion USD = dfrac110^3 cdot dfrac\n    tildeq_yrrsrc\n    barps_yrsrc\n\nFor e=oil\n\nbeginaligned\nq_yrr text trillion btu = left\n    energy(yrrsrcsec) vert src=cru sec=ref\nright\n\nv text billion USD = left\n    ned_yrrsrc=oilsec vert src=oil\nright\n\nv_yrrsrc=oil = dfrac\n    q_yrr\n    sum_r q_yrr\ncdot\nsum_rsec v_yrrsrcsec\nendaligned\n\nys_yrrs=eg=e = v_yrrsrc=e circ vec1_s=g circ map_srcrightarrow g\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_id0!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_id0!","text":"id0(yr,r,g=e,s), regional intermediate demand\n\nid_yrrgs =\nbegincases\nsum_sec left( ed_yrrsrcrightarrow g sec cdot alpha^inp_yrrgssec right)\n e in g\n\nid_yrrgs  eni g\nendcases\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_inpshr!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_inpshr!","text":"beginaligned\ninp_yrrgssec = \nbig\n    id_yrrgs circ map_srightarrow sec vert yr r srcin g s\n    qquadwedge pctgen_yrrsrcrightarrow gsec  001\nbig\n\nalpha^inp_yrrgssec = dfrac\n    inp_yrrgssec\n    sum_s inp_yrrgssec\nendaligned\n\nbeginaligned\ninp_yrrgssec = \nbig\n    inp_yrrgssec vert yr r srcin g s sec\n    qquadwedge ed_yrrsrcrightarrow gsec  0\n    qquadwedge ys_yrrsg=s  0\nbig\n\nhatalpha^inp_yrrgssec = dfrac\n    sum_r inp_yrrgssec\n    sum_rs inp_yrrgssec\nendaligned\n\nalpha^inp_yrrgssec =\nbegincases\nalpha^inp_yrrgssec  sum_s inp_yrrgssec neq 0\n\nhatalpha^inp_yrrgssec  sum_s inp_yrrgssec = 0\nendcases\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_m0!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_m0!","text":"m0(yr,r,g=ele), foreign imports\n\nbarm_yrrg=ele\n= left\n    trdele left(yrrtright) vert yr r t=imports\nright\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_x0!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_x0!","text":"x0(yr,r,g=ele), foreign exports\n\nbarx_yrrg=ele\n= left\n    trdele left(yrrtright) vert yr r t=exports\nright\n\n\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_zero_prod!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_zero_prod!","text":"\n\n\n\n","category":"function"},{"location":"man/build/eem/disagg_energy.html#SLiDE._disagg_energy_zero_island!","page":"Energy Disaggregation","title":"SLiDE._disagg_energy_zero_island!","text":"Set electricity imports (nd_yrrg) /exports (xn_yrrg) from/to the national market to/from Alaska and Hawaii to zero. \n\n\n\n\n\n","category":"function"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"using SLiDE, DataFrames","category":"page"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y = read_file(joinpath(SLIDE_DIR,\"docs\",\"src\",\"assets\",\"yaml\",\"gsp_state.yml\"));","category":"page"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"df = read_file([SLIDE_DIR; y[\"PathIn\"]], y[\"CSVInput\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Deselect","page":"Preparation","title":"Deselect","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Deselect\"]\ndf = edit_with(df, y[\"Deselect\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Rename","page":"Preparation","title":"Rename","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Rename\"]\ndf = edit_with(df, y[\"Rename\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Match","page":"Preparation","title":"Match","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Match\"]\ndf = edit_with(df, y[\"Match\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Melt","page":"Preparation","title":"Melt","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Melt\"]\ndf = edit_with(df, y[\"Melt\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Map","page":"Preparation","title":"Map","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"Standardize region names.","category":"page"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Map\"][1]\ndf = edit_with(df, y[\"Map\"][1]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"Standardize unit names and set up for the conversion from millions to billions of us dollars (USD).","category":"page"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Map\"][2]\ndf = edit_with(df, y[\"Map\"][2]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Replace","page":"Preparation","title":"Replace","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Replace\"]\ndf = edit_with(df, y[\"Replace\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Drop","page":"Preparation","title":"Drop","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Drop\"]\ndf = edit_with(df, y[\"Drop\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Operate","page":"Preparation","title":"Operate","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Operate\"]\ndf = edit_with(df, y[\"Operate\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Describe","page":"Preparation","title":"Describe","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Describe\"]\ndf = edit_with(df, y[\"Describe\"], y[\"CSVInput\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"man/data/preparation.html#Order","page":"Preparation","title":"Order","text":"","category":"section"},{"location":"man/data/preparation.html","page":"Preparation","title":"Preparation","text":"y[\"Order\"]\ndf = edit_with(df, y[\"Order\"]);\nshow(df, allcols = true, splitcols = false) # hide","category":"page"},{"location":"api/internals/parse.html#Parse","page":"Parse","title":"Parse","text":"","category":"section"},{"location":"api/internals/parse.html#Edit","page":"Parse","title":"Edit","text":"","category":"section"},{"location":"api/internals/parse.html","page":"Parse","title":"Parse","text":"Modules = [SLiDE]\nPages = [\"parse/edit_data.jl\"]\nPublic = false","category":"page"},{"location":"api/internals/parse.html#Load","page":"Parse","title":"Load","text":"","category":"section"},{"location":"api/internals/parse.html","page":"Parse","title":"Parse","text":"Modules = [SLiDE]\nPages = [\"parse/load_data.jl\"]\nPublic = false","category":"page"},{"location":"api/internals/parse.html#Verify","page":"Parse","title":"Verify","text":"","category":"section"},{"location":"api/internals/parse.html","page":"Parse","title":"Parse","text":"Modules = [SLiDE]\nPages = [\"parse/check_data.jl\"]\nPublic = false","category":"page"},{"location":"index.html#SLiDE-Documentation","page":"Home","title":"SLiDE Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Intro to SLiDE","category":"page"},{"location":"index.html#Getting-Started:-Installation-and-First-Steps","page":"Home","title":"Getting Started: Installation and First Steps","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Clone this repo to your local machine.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"> git clone https://github.com/NREL/SLiDE.git","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"From the SLiDE directory, open Julia using","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"> julia --project","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Build the SLiDE package from the Pkg REPL. Type ] to enter the Pkg REPL and run:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(SLiDE) pkg> build","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will generate the Manifest.toml file, including the package dependencies. If the directory SLiDE/data/ does not exist, this will download SLiDE input data.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Precompile the SLiDE package and build the model input data by running:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using SLiDE\njulia> d, set = build( ; eem=true)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Thomas F. Rutherford and Andrew Schreiber, \"Tools for Open Source, Subnational CGE   Modeling with an Illustrative Analysis of Carbon Leakage,\"   J Global Econ Anal 4(2): 1-66.","category":"page"},{"location":"man/parameters.html#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"Sharing:","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"alpha^*_yrrs - regional sharing parameter associated with the * dataset\nbeta^mar_yrrmg - share of trade and transport margins\nrho^cfs_rg - regional purchase coefficients\ntheta^ls_yrrs - share of labor in total value added","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"Non-sharing:","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"sigma - constant elasticity of substitution governing input trade offs in production\neta_rg - elasticity of transformation governing the supply of output to regional markets\ngamma - positive penalty on zero elements\nPi^X_rg - zero profit condition for X_rg\nPhi_rc denote the subset of (rc) with non-zero elements, Phi^C_rc denote its converse\npsi denote the cutoff point for large decreases relative to the reference level","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"DIY:","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"delta - sectoral disaggregation\n````\nOpen: zeta iota kappa lambda mu nu xi pi tau chi omega","category":"page"},{"location":"man/parameters.html#BEA-Supply/Use","page":"Parameters","title":"BEA Supply/Use","text":"","category":"section"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"Parameter Variables Description\nid0 (yr,i,j) Intermediate demand\nfd0 (yr,i,fd) Final demand\nva0 (yr,va,j) Value added\nts0 (yr,ts,j) Taxes and subsidies\nx0 (yr,i) Exports of goods and services\nys0 (yr,i,j) Sectoral supply\nm0 (yr,i) Imports\nmrg0 (yr,i) Trade margins\ntrn0 (yr,i) Transportation costs\ncif0 (yr,i) CIF/FOB Adjustments on Imports\nduty0 (yr,i) Import duties\ntax0 (yr,i) Taxes on products\nsbd0 (yr,i) Subsidies on products\ns0 (yr,j) Aggregate supply\ny0 (yr,i) Gross output\nbopdef0 (yr) Balance of payments deficit\nms0 (yr,i,m) Margin supply\nmd0 (yr,m,i) Margin demand\nfs0 (yr,i,fd) Household supply\na0 (yr,i) Armington supply\ntm0 (yr,i) Tax net subsidy rate on intermediate demand\nta0 (yr,i) Import tariff\nlshr0 (yr,g) Labor share of value added","category":"page"},{"location":"man/parameters.html#Sharing","page":"Parameters","title":"Sharing","text":"","category":"section"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"Parameter Variables Description\npce (yr,r,g) Regional shares of final consumption\nutd (yr,r,s,t) Share of total trade by region\ngsp (yr,r,s) Annual gross state product\nregion (yr,r,s) Regional shares of value added\nlabor (yr,r,s) Share of regional value added due to labor\nrpc (r,g) Regional purchase coefficient","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"Intermediate values","category":"page"},{"location":"man/parameters.html","page":"Parameters","title":"Parameters","text":"Parameter Variables Description\nnetval (yr,r,s) Net value added (compensation + surplus)\nseclaborshr (yr,s) Sector level average labor shares\navgwgshr (r,s) Average wage share\nd0 (r,g) Local supply-demand\nmrt0 (r,r,g) Interstate trade\nxn0 (r,g) National exports\nmn0 (r,g) National demand","category":"page"}]
}
